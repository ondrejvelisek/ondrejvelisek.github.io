"use strict";(self.webpackChunk_torrta_docs=self.webpackChunk_torrta_docs||[]).push([[13],{4888:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"tanstack-start-new-competitor-to-nextjs","metadata":{"permalink":"/tanstack-start-new-competitor-to-nextjs","source":"@site/blog/2025-11-17-tanstack-start-new-competitor-to-nextjs/index.mdx","title":"TanStack Start: New competitor to Next.js","description":"I\'ve been using TanStack Start for a mid-size hobby webapp since its early alpha stage\u2014over a year now.","date":"2025-11-17T00:00:00.000Z","tags":[],"readingTime":16.87,"hasTruncateMarker":true,"authors":[],"frontMatter":{"slug":"tanstack-start-new-competitor-to-nextjs","image":"./tanstack-start-new-competitor-to-nextjs.png","draft":false,"unlisted":false},"unlisted":false,"nextItem":{"title":"Avoid the State Synchronization Trap","permalink":"/avoid-state-synchronization-trap"}},"content":"import { Pro, Con } from \'@site/components/ProsCons\'\\nimport NextLogo from \'./NextLogo.tsx\';\\nimport StartLogo from \'./StartLogo.tsx\';\\nimport { Timeline, Marks, Mark, Swimlane, Block } from \'./Timeline.tsx\';\\nimport startLogoUrl from \'./start-logo.png\';\\nimport nextLogoUrl from \'./next-logo.png\';\\n\\n\\n\\nI\'ve been using TanStack Start for a mid-size hobby webapp since its early alpha stage\u2014over a year now.\\nI\'m starting to feel I have enough experience, and since Start just entered a release candidate stage,\\nit\'s time to share my insights with you.\\n\\nI will present Start by comparing it to Next.js.\\n\\n{/* truncate */}\\n\\nBoth are great pieces of software. In some cases very similar. In other cases very different.\\n\\nNotes:\\n- I assume you have basic knowledge of the Next.js App Router ([docs](https://nextjs.org/docs/app/getting-started)).\\n- This article is heavily inspired by my talk at FrontKon 2025 in Prague\\n([\ud83c\udfa5 YouTube](https://www.youtube.com/watch?v=wwiIgIKL7JA) Czech only).\\n- Actually, I compare TanStack Start ([docs](https://tanstack.com/start/)) + TanStack Router\\n([docs](https://tanstack.com/router/)) and reference both as just \\"Start\\" for simplicity.\\nIt feels like a natural comparison since Next.js also includes a router.\\n\\n&nbsp;\\n\\n## What do I compare?\\n\\nI will compare Start to Next in the following areas.\\nI chose these because, from my point of view, this is where the two frameworks differ the most.\\n\\n- Routing - Typesafety\\n- Data fetching - SSR, Streaming\\n- Performance - Bundle size, Caching\\n\\nOn the other hand, I will *not* compare:\\n\\n- Non-technical differences\\n  - Like production readiness, Vercel lock-in, community, ecosystem, ...\\n  - Because I like to dig the technical differences.\\n- Areas where they are very similar\\n  - Server actions/functions, progressive enhancement, SEO, hosting, ...\\n  - Because there are mostly syntactical differences, and I\'m not interested in these.\\n\\n&nbsp;\\n\\n## Routing\\n\\n&nbsp;\\n\\n### Route definition\\n\\nBoth frameworks support file-based routing. You define your pages based on your file/folder structure and naming conventions.\\nThere are some minor differences.\\nLike Next using `page.tsx` and Start using `index.tsx` files for page definition.\\nOr `[postId]` folder in Next and `$postId` in Start as a dynamic route segment.\\nJust syntactic sugar. No big difference here.\\n\\n<NextLogo/>\\n```\\n\ud83d\udcc1 blog\\n\u251c\u2500 \ud83d\udcc1 [postId]\\n\u2502  \u2514\u2500 \u269b page.tsx\\n\u2514\u2500 \u269b page.tsx\\n```\\n\\n<StartLogo/>\\n```\\n\ud83d\udcc1 blog\\n\u251c\u2500 \ud83d\udcc1 $postId\\n\u2502  \u2514\u2500 \u269b index.tsx\\n\u2514\u2500 \u269b index.tsx\\n```\\n\\n\\nMoving on. Start allows you to define so-called flat-route definitions. This means you can define your path in a file name instead of a folder.\\nFor example, a single file in the root folder `/blog.$postId.tsx` in Start will define the same route as `/blog/[postId]/page.tsx` in Next.\\nFrom my experience, it is often useful and readable,\\nespecially when you use it in combination with classic nested folders definitions.\\n\\n<StartLogo/>\\n```markup title=\\"Flat-route definition\\"\\n\u269b blog.tsx\\n\u269b blog.$postId.tsx\\n```\\n\\n<StartLogo/>\\n```markup title=\\"Combined flat-route with nested folders\\"\\n\ud83d\udcc1 blog\\n\u251c\u2500 \u269b $postId.tsx\\n\u2514\u2500 \u269b index.tsx\\n```\\n\\n\\n&nbsp;\\n\\n### Page config\\n\\nNow let\'s look inside a page file. Next.js uses an extremely brief and readable syntax. Love it.\\n\\n<NextLogo/>\\n```tsx title=\\"/blog/page.tsx\\"\\nexport default function Blog() {\\n  return <div/>;\\n}\\n```\\n\\nStart is a little more complicated. We need to use the `createFileRoute(...)` function.\\nWorth pointing out its first argument `/blog`.\\nIt\'s the route identifier and is used internally to infer TypeScript types.\\nWhat\'s convenient is that the first line is auto-generated\\nand the route identifier is derived from the file name by Start dev server.\\nThis way it prevents typos and misalignments between the file name, route identifier and type inference.\\n\\n<StartLogo/>\\n```tsx title=\\"/blog/index.tsx\\"\\n  // highlight-next-line\\nexport const Route = createFileRoute(\\"/blog\\")({ // this is auto-generated\\n  component: Blog,\\n});\\n\\nfunction Blog() {\\n  return <div/>;\\n}\\n```\\n\\n&nbsp;\\n\\n### Router typesafety\\n\\nNow let\'s look at how the dynamic route segment parameter `postId` is used. In Start, it\'s pretty simple\u2014just use the `useParams` hook.\\nIt\'s worth mentioning that `useParams` is typesafe, and your IDE will suggest available param names and catch typos.\\n\\n<StartLogo/>\\n```tsx title=\\"/blog/$postId.tsx\\"\\nexport const Route = createFileRoute(\\"/blog/$postId\\")({\\n  component: BlogPost,\\n});\\n\\nfunction BlogPost() {\\n  // highlight-next-line\\n  const { postId } = Route.useParams();\\n  return <div>{postId}</div>;\\n}\\n```\\n\\nLet\'s look at how it is done in Next. See that it also needs a route identifier to infer types. This way, `params` are also typed.\\nNote that this only works if you use the `typedRoutes` feature\\n([docs](https://nextjs.org/docs/app/api-reference/config/typescript#statically-typed-links)).\\nWithout it, there\'s no type inference, your IDE won\'t offer suggestions, and AI agents won\'t benefit from it either.\\n\\n<NextLogo/>\\n```tsx title=\\"/blog/[postId]/page.tsx\\"\\nexport default async function BlogPost(\\n  // highlight-next-line\\n  { params }: PageProps<\\"/blog/[postId]\\">\\n) {\\n  const { postId } = await params;\\n  return <div>{postId}</div>;\\n}\\n```\\n\\nI love how competition is driving change here. \\nWhen TanStack Router came out with its awesome and convenient end-to-end typesafe system, developers loved it.\\nQuickly it forced Next.js and Remix to invest in it too. In version 15.5, Next.js introduced a new `typedRoutes` feature\\n([blog post](https://nextjs.org/blog/next-15-5#typed-routes-stable)).\\nIt is not enabled by default, and I highly suggest enabling it.\\nIt\'s a great <abbr title=\\"Developer Experience\\">DX</abbr> improvement; however, you might be surprised that it is not as reliable as you would expect.\\nLet\'s see some examples.\\n\\nFirstly, a `<Link/>` component. As you can see, Next can\'t infer routes with dynamic segments, and therefore your IDE is not able to suggest all available routes.\\nInconvenient for devs and from my experience it confuses AI agents too.\\n\\n<NextLogo/>\\n```tsx\\n<Link href=\\"\\">Blog Post</Link>\\n//          \u2b11 IDE suggests:\\n//            \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\\n//            \u2503 /       \u2503\\n//            \u2503 /blog   \u2503\\n//            \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\\n```\\n\\n<StartLogo/>\\n```tsx\\n<Link to=\\"\\">Blog Post</Link>\\n//        \u2b11 IDE suggests:\\n//          \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\\n//          \u2503 /             \u2503\\n//          \u2503 /blog/        \u2503\\n// highlight-next-line\\n//          \u2503 /blog/$postId \u2503\\n//          \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\\n```\\n\\nAnother example. Next does not URL-encode dynamic parameters. In this case, Next renders a `<a href=\\"/blog/\\">` tag referencing the blog page.\\nAllowing it, even if route `/blog/` is not defined anywhere in our app. Type checking passes, and users end up on a 404 page.\\n\\n<NextLogo/>\\n```tsx\\n<Link href=\\"/blog/ \\">\\n  Blog Post\\n</Link>\\n```\\n\\nStart correctly encodes the space and renders a `<a href=\\"/blog/%20\\">` tag\\npointing to the blog post page with `postId` being a space (encoded as `%20`).\\nI know it\'s a rare case, but it does make me keep checking for correctness in Next.\\n\\n<StartLogo/>\\n```tsx\\n<Link to=\\"/blog/$postId\\" params={{ postId: \\" \\" }}>\\n  Blog Post\\n</Link>\\n```\\n\\nAnd in my opinion, the biggest Next flaw: it does not type search query params. At all.\\nYou are on your own. Start has you covered. It even supports validation libraries like Zod for more complex data structures\\n([docs](https://tanstack.com/router/latest/docs/framework/react/guide/search-params#validating-and-typing-search-params)).\\n\\n<StartLogo/>\\n```tsx\\nexport const Route = createFileRoute(\\"/blog\\")({\\n  component: Blog,\\n  validateSearch: z.object({\\n  // highlight-next-line\\n    postId: z.string().optional(),\\n  }),\\n});\\n```\\n```tsx\\n<Link \\n  to=\\"/blog\\"\\n  // highlight-next-line\\n  search={{ postId: \\"123\\" }}\\n>\\n  Blog Post\\n</Link>\\n```\\n\\n&nbsp;\\n\\n&nbsp;\\n\\nTo summarize: Start is more flexible in defining routes. It supports file-based with flat-config definition.\\nStart forced Next to introduce the `typedRoutes` feature. Turn it on if you use Next.\\nHowever even with it enabled, Next is not 100% typesafe. Start is, and it is very convenient for both devs and AI agents.\\n(Here it may seem I\'m talking about Start advantages and Next flaws only. But later I also highlight the opposite. Keep reading :)  \\n\\n&nbsp;\\n\\n## Data fetching\\n\\n&nbsp;\\n\\n### Collocation\\n\\nThis is how Next.js loads data. \\nJust use an async component and await within the component body.\\nExtremely convenient.\\n\\n<NextLogo/>\\n```tsx\\nasync function Blog() {\\n  // highlight-next-line\\n  const posts = await getPosts();\\n  return posts.map(() => <>...</>);\\n}\\n```\\n\\nIn Start\'s [documentation](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#route-loaders), the recommended way is to use the Route loader.\\n\\n<StartLogo/>\\n```tsx\\nexport const Route = createFileRoute(\\"/blog\\")({\\n  component: Blog,\\n  // highlight-next-line\\n  loader: async () => await getPosts(),\\n});\\n\\nfunction Blog() {\\n  // highlight-next-line\\n  const posts = Route.useLoaderData();\\n  return posts.map(() => <>...</>);\\n}\\n```\\n\\nPersonally, I do not like this pattern. It is more verbose.\\nBut what\'s more important than syntax is that the component becomes dependent on a route.\\nThe Blog component cannot be easily used elsewhere in the app.\\nI always have to remember to update the parent route loader as well.\\nIn the case of a Blog component, it is quite simple, but imagine a deeper and more reusable component\\nlike an `<AuthorAvatar/>` with a tooltip.\\nIt can be used on a blog post page, then extended to a list of posts, list of authors, author details page, favourite posts, etc.\\nIn all those places, I would need to remember to update the parent route loader.\\n\\nTherefore, I recommend integrating TanStack Start with TanStack Query.\\nThe data loading example would then look like this.\\n\\n<StartLogo/>\\n```tsx\\nfunction Blog() {\\n  // highlight-next-line\\n  const posts = useSuspenseQuery({\\n    queryKey: [\'posts\'],\\n    queryFn: () => getPosts(),\\n  });\\n  return posts.data.map(() => <>...</>);\\n}\\n```\\n\\nIt\'s still more verbose than Next, but we get rid of the route dependency.\\n\\nYou may think that this way it stops being prefetched and may create waterfalls. And you\'d be correct.\\nHowever `useSuspenseQuery` can opt-in to being prefetched.\\nBoth frameworks do it similarly by hoisting the query to the top of the route.\\nNext uses `void getPosts()` syntax, Start uses `queryClient.fetchQuery(...)`.\\nI will not go into details. Let\'s just say both frameworks are very similar.\\n\\n&nbsp;\\n\\n### Streaming\\n\\nThere is another way to compare Next and Start data fetching: performance.\\nLet\'s look at the request timeline of Next request with awaited data fetching.\\n\\n<NextLogo/>\\n<Timeline>\\n  <Marks>\\n    <Mark start={0} title=\\"Request\\" />\\n  </Marks>\\n  <Swimlane start={0} end=\\"FCP+LCP\\">\\n    <Block type=\\"server\\" duration={1} />\\n    <Block type=\\"fetch\\" duration={8} />\\n    <Block type=\\"server\\" duration={2} />\\n    <Block type=\\"network\\" duration={4} />\\n    <Block type=\\"client\\" duration={1} />\\n  </Swimlane>\\n</Timeline >\\n\\nYou can see that awaiting data in Next.js blocks rendering on the server during the fetch. The <abbr title=\\"First Contentful Paint\\">FCP</abbr> metric suffers.\\nStart does the same. It\'s actually even a little worse because it typically needs to transfer more data over the network to the client.\\nBecause Start does not support React Server Components (yet, [blog post](https://tanstack.com/blog/tanstack-2-years#whats-next)),\\nit has to transfer more JS components together with data needed to hydrate them.\\n\\n<StartLogo/>\\n<Timeline>\\n  <Marks>\\n    <Mark start={0} title=\\"Request\\" />\\n  </Marks>\\n  <Swimlane start={0} end=\\"FCP+LCP\\">\\n    <Block type=\\"server\\" duration={1} />\\n    <Block type=\\"fetch\\" duration={8} />\\n    <Block type=\\"server\\" duration={2} />\\n    <Block type=\\"network\\" duration={5} />\\n    <Block type=\\"client\\" duration={1} />\\n  </Swimlane>\\n</Timeline >\\n\\nFortunately, both frameworks support streaming.\\nBoth adopted React\'s `<Suspense/>` component, and luckily for us, without any configuration.\\nIt\'s enough to just wrap our component within `<Suspense/>`,\\nand the content will be streamed, greatly improving both <abbr title=\\"First Contentful Paint\\">FCP</abbr> and <abbr title=\\"Largest Contentful Paint\\">LCP</abbr>.\\n\\n<NextLogo cls=\\"-left-7\\"/>\\n<StartLogo/>\\n```tsx\\n<Suspense>\\n  <Blog />\\n</Suspense>\\n```\\n\\n<NextLogo cls=\\"-left-7\\"/>\\n<StartLogo/>\\n<Timeline>\\n  <Marks>\\n    <Mark start={0} title=\\"Request\\" />\\n  </Marks>\\n  <Swimlane start={0} end=\\"FCP\\">\\n    <Block type=\\"server\\" duration={3} />\\n    <Block type=\\"network\\" duration={4} />\\n    <Block type=\\"client\\" duration={1} />\\n  </Swimlane>\\n  <Swimlane start={1} end=\\"LCP\\">\\n    <Block type=\\"fetch\\" duration={8} />\\n    <Block type=\\"server\\" duration={1} />\\n    <Block type=\\"network\\" duration={3} />\\n    <Block type=\\"client\\" duration={1} />\\n  </Swimlane>\\n</Timeline>\\n\\n&nbsp;\\n\\n### Fetching with parameters\\n\\nOften you need to pass some parameters to the fetching endpoint, like `postId`.\\nWe already covered how to get route params in the [Routing section](#router-typesafety).\\nNow let\'s just combine it with fetching.\\n\\nIn Start, we can simply use the `useParams` hook directly in the component and pass `postId` to the query.\\nThe syntax is a little verbose, but I love the collocation of code and component independence.\\n\\n<StartLogo/>\\n```tsx\\nfunction BlogPost() {\\n  // highlight-next-line\\n  const { postId } = Route.useParams();\\n  const post = useSuspenseQuery({\\n    queryKey: [\'posts\', postId],\\n    queryFn: () => getPost(postId),\\n  });\\n  return <div>{post.title}</div>;\\n}\\n```\\n\\nIn Next.js, we access the `params` prop in the page component. Seems pretty straightforward. \\nBut there is a catch. Do you see it?\\n\\n<NextLogo/>\\n```tsx\\n// /blog/page.tsx\\nexport default async function BlogPost(\\n  { params }: PageProps<\\"/blog/[postId]\\">\\n) {\\n  // highlight-next-line\\n  const { postId } = await params;\\n  const post = await getPost(postId);\\n  return <div>{post.title}</div>;\\n}\\n```\\n\\nIn Next, we can only get `params` prop in the root page component. `params` are _not_ accessible in nested components.\\nThis can cause problems. Imagine the `<AuthorAvatar/>` component again, which consumes the `postId` param.\\nIt will be nested somewhere deep in the component tree.\\n\\nWe need to drill `postId` through each component of the tree until we reach the `<AuthorAvatar/>` component.\\nYour first idea is probably to use React Context to avoid prop drilling. But it is not allowed in server components.\\nIt throws \\n<mark class=\\"error\\">Error: React Context is unavailable in Server Components</mark>.\\nOuch. We either need to prop drill, use client components, or refactor our component structure.\\nEither way, it is a lot of work for such a common task.\\n\\n<NextLogo/>\\n```tsx\\n<BlogPostPage/>\\n      \u2b07 postId\\n<PostContent/>\\n      \u2b07 postId\\n<PostHeader/>\\n      \u2b07 postId\\n<PostAuthor/>\\n      \u2b07 postId\\n<AuthorAvatar/>\\n```\\n\\n&nbsp;\\n\\n&nbsp;\\n\\nTo summarize data fetching:\\nI recommend integrating Start with TanStack Query for better code collocation, component reusability, and independence.\\nBoth Next and Start support streaming via `<Suspense/>` out of the box. And both frameworks can avoid network waterfalls similarly.\\nNext uses more concise syntax, but it is not as ergonomic when accessing params in nested components.\\n\\n&nbsp;\\n\\n## Performance\\n\\n&nbsp;\\n\\n### Bundle size\\n\\nSo far, it looks like TanStack Start is overall better than Next. But here Start loses.\\nStart does not support React Server Components yet ([blog post](https://tanstack.com/blog/tanstack-2-years#whats-next)),\\nand therefore all code is bundled and shipped to the client\u2014even parts that are static and don\'t update on the client.\\nNext allows you to select which components go to the client and which ones stay server-only.\\nServer-only is the default and component is sent to the client only when marked with `\\"use client\\"`.\\nIt can make the client bundle smaller.\\nThis means less code is shipped to the client, resulting in less network transfer, faster hydration time, and therefore faster <abbr title=\\"Time to Interactive\\">TTI</abbr>.\\n\\n<NextLogo/>\\n<Timeline>\\n  <Marks>\\n    <Mark start={0} title=\\"Request\\" />\\n  </Marks>\\n  <Swimlane start={0} end=\\"FCP\\">\\n    <Block type=\\"server\\" duration={2} />\\n    <Block type=\\"network\\" duration={3} title=\\"HTML doc\\" />\\n    <Block type=\\"client\\" duration={1} title=\\"Processing HTML\\" />\\n  </Swimlane>\\n  <Swimlane start={6} end=\\"TTI\\">\\n    <Block type=\\"server\\" duration={1} />\\n    <Block type=\\"network\\" duration={5} title=\\"Bundle transfer\\" />\\n    <Block type=\\"client\\" duration={2} title=\\"Hydration\\" />\\n  </Swimlane>\\n</Timeline >\\n\\n<StartLogo/>\\n<Timeline>\\n  <Marks>\\n    <Mark start={0} title=\\"Request\\" />\\n  </Marks>\\n  <Swimlane start={0} end=\\"FCP\\">\\n    <Block type=\\"server\\" duration={2} />\\n    <Block type=\\"network\\" duration={3} title=\\"HTML doc\\" />\\n    <Block type=\\"client\\" duration={1} title=\\"Processing HTML\\" />\\n  </Swimlane>\\n  <Swimlane start={6} end=\\"TTI\\">\\n    <Block type=\\"server\\" duration={1} />\\n    <Block type=\\"network\\" duration={9} title=\\"Bundle transfer\\" />\\n    <Block type=\\"client\\" duration={3} title=\\"Hydration\\" />\\n  </Swimlane>\\n</Timeline >\\n\\nDepending on how static your app content is, this can have a significant impact on performance.\\nLet\'s briefly go through the examples of a static and a dynamic component.\\n\\nA static component could be a `<NavigationBar/>` or an `<ArticleContent/>`. You can still update them sometimes,\\nbut it is probably fine if they are stale for a few minutes or even hours after the update.\\n\\nA dynamic component could be a `<CommentSection/>` or a `<LikesCounter/>`.\\nIt would be a problem if a user sent a comment or pressed a like button but needed to wait several minutes or hours to see it reflected on the page.\\n\\nThat being said, Next has quite a performance advantage in highly static apps\u2014or what some would call websites.\\n\\n&nbsp;\\n\\n### Caching and Prerendering\\n\\nNext defines 4 layers of caching ([docs](https://nextjs.org/docs/14/app/building-your-application/caching#overview)).\\nStart fully supports 3 of them. Full Route Cache is supported partially. Let\'s talk about it.\\n\\n| Cache layer      | What it caches | Purpose | <img src={nextLogoUrl} alt=\\"Next Logo\\" className=\\"w-8 block\\"/> |  <img src={startLogoUrl} alt=\\"Start Logo\\" className=\\"w-8 block\\"/> |\\n| :---- | :---- | :---- | :---- | :---- |\\n| Request Memoization      | Return values of functions       | Re-uses data in a React Component tree on a server during one request | \ud83d\udfe2 | \ud83d\udfe2 |\\n| Data Cache   | Data        | Stores data across user requests and deployments | \ud83d\udfe2 | \ud83d\udfe2 |\\n| Full Route Cache   | HTML and <abbr title=\\"React Server Components\\">RSC</abbr> payload        | Reduces server rendering effort for each request | \ud83d\udfe2 | \ud83d\udfe0 |\\n| Router Cache   | <abbr title=\\"React Server Components\\">RSC</abbr> Payload        | Reduces server requests on navigation | \ud83d\udfe2 | \ud83d\udfe2 |\\n\\nYou might know Full Route Cache under other names like Prerendering or Static Generation.\\nThe main idea is to render a page once\u2014either during build time or during the first request\u2014store the rendered HTML, and serve it from cache on subsequent requests.\\nThis way, the best <abbr title=\\"First Contentful Paint\\">FCP</abbr> is achieved.\\nBoth Start and Next support this feature. Next has it enabled by default;\\nStart is opt-in ([docs](https://tanstack.com/start/latest/docs/framework/react/guide/static-prerendering)).\\nNext has an easier way to invalidate cache. As far as I know, Start needs to rebuild all pages,\\nwhich is not a problem for small apps, but for large ones it can take a while and is annoying.\\nNevertheless, for the end user, the experience and performance are equal.\\n\\n<NextLogo cls=\\"-left-7\\"/>\\n<StartLogo/>\\n<Timeline>\\n  <Marks>\\n    <Mark start={0} title=\\"Build\\" />\\n    <Mark start={8} title=\\"Request\\" />\\n  </Marks>\\n  <Swimlane start={0}>\\n    <Block type=\\"server\\" duration={1} />\\n    <Block type=\\"fetch\\" duration={5} />\\n    <Block type=\\"server\\" duration={1} />\\n  </Swimlane>\\n  <Swimlane start={8} end=\\"FCP\\">\\n    <Block type=\\"server\\" duration={1} />\\n    <Block type=\\"network\\" duration={3} />\\n    <Block type=\\"client\\" duration={1} />\\n  </Swimlane>\\n</Timeline >\\n\\nIn the real world however, a lot of pages are not fully static or fully dynamic. They contain some static and some dynamic parts\u2014components.\\nImagine a blog post page. It contains a header with author avatar and name, article content, and a comments section.\\n`<Author/>` and `<Article/>` are static, but because of the `<Comments/>` component, we would not be able to prerender and cache the page.\\n\\n```tsx\\n            <BlogPostPage/>\\n      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n  <Author/>   <Article/>   <Comments/>\\n```\\n\\nNext solves this problem with Cached Components ([docs](https://nextjs.org/docs/app/getting-started/cache-components), previously called Partial Prerendering).\\nThis way, some components (called shell) are rendered during build and sent to the client immediately when requested,\\nwhile the server fetches dynamic data, renders the rest, and streams it to the client.\\nThis way, we can prerender the `<Author/>` and `<Article/>` components and stream the `<Comments/>` section during the request. \\nStart does not provide any support for Cached Components.\\n\\n<NextLogo/>\\n<Timeline>\\n  <Marks>\\n    <Mark start={0} title=\\"Build\\" />\\n    <Mark start={8} title=\\"Request\\" />\\n  </Marks>\\n  <Swimlane start={0}>\\n    <Block type=\\"server\\" duration={1} />\\n    <Block type=\\"fetch\\" duration={5} />\\n    <Block type=\\"server\\" duration={1} />\\n  </Swimlane>\\n  <Swimlane start={8} end=\\"FCP\\">\\n    <Block type=\\"server\\" duration={2} />\\n    <Block type=\\"network\\" duration={3} />\\n    <Block type=\\"client\\" duration={1} />\\n  </Swimlane>\\n  <Swimlane start={9} end=\\"LCP\\">\\n    <Block type=\\"fetch\\" duration={6} />\\n    <Block type=\\"server\\" duration={1} />\\n    <Block type=\\"network\\" duration={2} />\\n    <Block type=\\"client\\" duration={1} />\\n  </Swimlane>\\n</Timeline >\\n\\n&nbsp;\\n\\n&nbsp;\\n\\nTo summarize: Start has a lot of performance optimizations, but Next wins, especially for highly static websites.\\nNext supports <abbr title=\\"React Server Components\\">RSC</abbr>, which results in a smaller bundle and faster <abbr title=\\"Time to Interactive\\">TTI</abbr> for end users.\\nNext supports Cached Components, which improves <abbr title=\\"First Contentful Paint\\">FCP</abbr> for static pages with some dynamic parts.\\n\\n&nbsp;\\n\\n## Summary\\n\\nSo which one is better? Next or Start?\\n\\n<div className=\\"flex flex-col gap-1 pb-6 w-fit\\">\\n  <div className=\\"rounded-md pr-4 p-2 bg-[#212432] w-fit flex items-center gap-2  mx-2 mr-4\\">\\n    <img src={nextLogoUrl} alt=\\"Next Logo\\" className=\\"w-8 block relative -ml-6\\"/>\\n    <>Concise syntax that feels productive</>\\n  </div>\\n  <div className=\\"rounded-md pl-4 p-2 bg-[#212432] w-fit self-end flex items-center gap-2 mx-2 ml-4\\">\\n    <>Flexible route definition with flat-config</>\\n    <img src={startLogoUrl} alt=\\"Start Logo\\" className=\\"w-8 block relative -mr-6\\" />\\n  </div>\\n  <div className=\\"rounded-md pr-4 p-2 bg-[#212432] w-fit flex items-center gap-2  mx-2 mr-4\\">\\n    <img src={nextLogoUrl} alt=\\"Next Logo\\" className=\\"w-8 block relative -ml-6\\"/>\\n    <>Smaller bundle size and therefore better TTI</>\\n  </div>\\n  <div className=\\"rounded-md pl-4 p-2 bg-[#212432] w-fit self-end flex items-center gap-2  mx-2 ml-4\\">\\n    <>Advanced router typesafety that I can rely on</>\\n    <img src={startLogoUrl} alt=\\"Start Logo\\" className=\\"w-8 block relative -mr-6\\" />\\n  </div>\\n  <div className=\\"rounded-md pr-4 p-2 bg-[#212432] w-fit flex items-center gap-2  mx-2 mr-4\\">\\n    <img src={nextLogoUrl} alt=\\"Next Logo\\" className=\\"w-8 block relative -ml-6\\"/>\\n    <>Granular prerendering and therefore better FCP</>\\n  </div>\\n  <div className=\\"rounded-md pl-4 p-2 bg-[#212432] w-fit self-end flex items-center gap-2 mx-2 ml-4\\">\\n    <>Ergonomic access to path params with better collocation</>\\n    <img src={startLogoUrl} alt=\\"Start Logo\\" className=\\"w-8 block relative -mr-6\\" />\\n  </div>\\n</div>\\n\\nBoth are trying to catch up with each other. But if I had to simplify and answer in a single sentence:\\n\\n> **Next.js app is more performant for end users** <br/>\\n> **TanStack Start app is easier to develop and maintain**\\n\\nCurrently, I would recommend using Next for mostly static websites where its performance-focused approach can outshine Start,\\nor where site performance has a high impact on your business\u2014for example, when you know every 100 ms of latency costs you $$$ in revenue.\\n\\nIn all other cases, I would recommend using TanStack Start.\\nIt\'s performant enough for most cases, and due to its better <abbr title=\\"Developer Experience\\">DX</abbr>, it can save you time during development and maintenance.\\nAnd it scales for bigger apps.\\n\\nLastly, I want to say I love seeing the frontend market grow and competition pushing and inspiring each other to improve.\\n\\nThank you for reading.\\n\\n\\n\\nimport Gisqus from \'@site/components/Gisqus\';\\n\\n<Gisqus/>"},{"id":"avoid-state-synchronization-trap","metadata":{"permalink":"/avoid-state-synchronization-trap","source":"@site/blog/2025-04-14-avoid-state-synchronization-trap/index.mdx","title":"Avoid the State Synchronization Trap","description":"This post is about a bad code pattern I see quite often.","date":"2025-04-14T00:00:00.000Z","tags":[],"readingTime":11.37,"hasTruncateMarker":true,"authors":[],"frontMatter":{"slug":"avoid-state-synchronization-trap","image":"./avoid-state-sync-trap-diagram.png","draft":false,"unlisted":false},"unlisted":false,"prevItem":{"title":"TanStack Start: New competitor to Next.js","permalink":"/tanstack-start-new-competitor-to-nextjs"},"nextItem":{"title":"How Next.js breaks React Fundamentals (Examples)","permalink":"/how-nextjs-breaks-react-fundamentals"}},"content":"import { Pro, Con } from \'@site/components/ProsCons\'\\n\\n\\n\\nThis post is about a bad code pattern I see quite often.\\nIt\u2019s about state management, particularly state synchronization. Often it is a source of bugs, glitches, and performance problems.\\n\\nUsually it is solvable by adjusting the state shape.\\nMore precisely, splitting the state into pieces and merging the pieces later in selectors, render functions, or custom hooks.\\nAn interesting fact is that one of those states is empty or undefined, but the UI renders desired items anyway. It might seem unintuitive, but bear with me.\\n\\n{/* truncate */}\\n\\nDuring the Redux era, we discussed state shape a lot. It was called state normalization.\\nNowadays, it is rarely touched, even though it is still important.\\nTo make my thoughts easier to understand, I sometimes use Redux terminology, like selectors and actions, throughout this article.\\n\\nI\u2019ll present the problem using an example of an orders table. The example is quite long, but I believe it is useful.\\nIt is based on a real-world application. I simplify, but in principle, I saw it in a real codebase.\\n\\nOne last note before we start: I talk about React but the ideas are applicable to any modern FE framework (regardless if signal-based or not).\\n\\n\\n\\n&nbsp;\\n\\n## Example\\n\\nLet\u2019s illustrate state synchronization through an evolving example, starting simply and becoming increasingly complex over several hypothetical years.\\n\\n\\n\\n&nbsp;\\n\\n### 2025: List of Orders\\n\\nimport ExampleOrdersList from \'./Example/Example1OrdersList\'\\n\\n<ExampleOrdersList/>\\n\\n```tsx\\nfunction OrdersList() {\\n    const orders = useOrders();\\n    return <Table data={orders} />;\\n}\\n```\\n\\nIt\u2019s the year 2025, and you work on this cool project called Outstanding Overview of Opulus Orders (OOoOO).\\nYou work on a page with a data table: a list of orders.\\nComponent `OrdersList` uses hook `useOrders`, which internally uses TanStack Query to fetch orders from a backend API.\\nWith the given orders data, you use a UI component `Table`, which renders it. Easy peasy.\\n\\n\\n\\n&nbsp;\\n\\n### 2026: Custom Columns\\n\\nimport Example2Columns from \'./Example/Example2Columns\'\\n\\n<Example2Columns/>\\n\\n```tsx\\nfunction OrdersList() {\\n  const [columns] = useContext(ColumnsCtx)\\n  const orders = useOrders(columns)\\n  return <Table data={orders} />\\n}\\n```\\n\\n```tsx\\nconst initColumns = [\\n  { attribute: \'date\' },\\n  { attribute: \'order\' },\\n  { attribute: \'customer\' },\\n  { attribute: \'amount\' },\\n]\\n\\nfunction ColumnsProvider() {\\n  const [columns, setColumns] = useState(initColumns)\\n  ...\\n}\\n```\\n\\nFast forward. It\u2019s the year 2026, and your customer\u2019s business has grown internationally, introducing new requirements.\\nThey collect additional attributes about Opulus orders, like currency and country.\\nThey want to allow users to show more columns in the table. So you add a <code>\u2699</code> button beside the table header.\\nWhen the user clicks it, a dropdown with available columns appears. The user can select and deselect which columns are visible.\\n\\nSince visible columns might change, they can\u2019t be a constant and you need to store them in some kind of updatable state.\\nThey need to be accessed from multiple components (like `OrdersList` and the <code>\u2699</code> button dropdown).\\nTo avoid prop drilling, we store columns in some higher-level state.\\nHere I use React Context `ColumnsCtx`, but feel free to imagine Zustand, Jotai, Redux, or URL. It does not matter for our purposes.\\nYou initialize the state with a constant containing the default columns.\\n(If URL surprised you, you might want to read my previous article [Conceptual Model of React and RSC](/conceptual-model-of-react-and-rsc)).\\n\\n\\n\\n&nbsp;\\n\\n### 2027: Filters\\n\\nimport Example3Filters from \'./Example/Example3Filters\'\\n\\n<Example3Filters/>\\n\\n```tsx\\nfunction Filters() {\\n  const [filters] = useContext(FiltersCtx)\\n  return filters.map(filter => (\\n    <Filter filter={filter} />\\n  ))\\n}\\n```\\n\\n```tsx\\nfunction OrdersList() {\\n  const [columns] = useContext(ColumnsCtx)\\n  const [filters] = useContext(FiltersCtx)\\n  const orders = useOrders(columns, filters)\\n  return <Table data={orders} />\\n}\\n```\\n\\n```tsx\\ntype Filters = Array<{\\n  attribute: string,\\n  operator?: \'=\'|\'>\'|\'<\',\\n  values?: Array<string|number>\\n}>\\n\\nfunction FiltersProvider() {\\n  const [filters, setFilters] = useState()\\n  ...\\n}\\n```\\n\\nFast forward to 2027. The customer\u2019s business continues to grow. There are many Opulus orders now.\\nTherefore, the customer wants you to implement filtering rows by values.\\nThe user should be able to filter only visible columns.\\nNot a trivial feature request, but let\u2019s do it.\\n\\nYou add a new `Filters` component.\\nSimilarly to columns, the visible filters might change. They can\u2019t be a constant and you need to store them in a state.\\nThey are required by multiple components. So to avoid prop drilling, you store them in a new Context `FiltersCtx`.\\n\\nFiltering works as follows:\\nThe user selects a filter value, e.g., Customer \u2018Ondrej\u2019.\\nThe state setter is called from `Filter` component.\\nThe `FiltersCtx` state value is updated.\\nThe reactivity system rerenders the `OrdersList` component.\\n`useOrders` hook receives updated state and refetches data with new `filters`.\\n\\nYou can try it by yourself with interactive working example above.\\n\\n\\n&nbsp;\\n\\n## State Initialization\\n\\nSeems nice. You try to run the code, and\u2026 it does not show any filters. Can you guess why?\\n(Note I\u2019ve already fixed the example above, to illustrate what we are trying to build)\\n\\nIt is because the filters context is empty. We need to initialize the filter state.\\n`useState` has an initialization property. We can use it.\\n\\nimport Example4Initialized from \'./Example/Example4Initialized\'\\n\\n<Example4Initialized/>\\n\\n```tsx\\nconst initColumns = [\\n  { attribute: \'date\' },\\n  { attribute: \'order\' },\\n  { attribute: \'customer\' },\\n  { attribute: \'amount\' },\\n]\\n\\nfunction FiltersProvider() {\\n  const [filters, setFilters] = useState(initColumns)\\n  ...\\n}\\n```\\n\\nIt shows the filters now. But\u2026\\n\\nWhen you add or remove columns, the filters are not updated.\\nThe desired behavior is: when the user adds a new column, the filter for this column is also added.\\nIn other words, synchronize columns and filters states.\\nMaybe this will help?\\n\\n```tsx\\nfunction FiltersProvider() {\\n  const [columns] = useContext(ColumnsCtx)\\n  const [...] = useState(columns)\\n  ...\\n}\\n```\\n\\nNope. Filters are still static because the `useState` argument is used at the first render only.\\nWe need to update the filters state somehow.\\n\\n\\n\\n&nbsp;\\n\\n## State Synchronization\\n\\n### 1. Direct Setters Approach\\n\\nimport Attempt3Setter from \'./Example/Attempt3Setter\'\\n\\n<Attempt3Setter/>\\n\\n```tsx\\nconst onAddColumnClick = (attribute) => {\\n    addColumn(attribute)\\n    addFilter(attribute)\\n}\\n```\\n\\nThis works. Finally\u2026 Oops. You forgot to synchronize the remove column handler.\\nFast forward. 2028. You are implementing reset columns to default. Oops. Forgot to reset filters as well.\\nFast forward. 2029. Implementing column presets. Oops. Forgot to update filters as well.\\nFast forward. 2030. Oops\u2026\\n\\nYou got the idea. Every time new functionality updating columns is added, you must also remember to update the filters.\\nThis is unmaintainable and error-prone.\\n\\n<ul className=\\"list-none pl-2\\">\\n  <Pro>Simple</Pro>\\n</ul>\\n<ul className=\\"list-none pl-2\\">\\n  <Con>Unmaintainable in a long run</Con>\\n</ul>\\n\\n\\n\\n&nbsp;\\n\\n### 2. Gate Setter Approach\\n\\n```tsx\\nfunction ColumnsProvider() {\\n  const [columns, setColumnsInner] = useState(initColumns)\\n  const { setFilters } = useContext(FiltersContext)\\n  const setColumns = (columns) => {\\n    setColumnsInner(columns)\\n    setFilters(columns)\\n  }\\n  // use setColumns instead of setColumnsInner\\n  ...\\n}\\n```\\n\\nSo naturally you centralized state update logic and moved the setter closer to the state, creating some kind of gate where all updates must come through.\\nIn `ColumnsProvider`, you implemented a `setColumns` wrapper function.\\n\\nIt works\u2026 Oops. Now, when you add a new column, all filters are reset.\\nSo you need to write some merge function which modifies only filters that changed.\\n\\n```tsx\\nconst setColumns = (columns) => {\\n    setColumnsInner(columns)\\n    setFilters(prevFilters =>\\n        mergeFilters(prevFilters, columns)\\n    );\\n}\\n```\\n\\nIt is definitely a better approach, but if you\u2019re like me, you feel it is still fragile in the long run.\\nAfter some years and several new colleagues, somebody will create code that calls `setColumnsInner` directly without your gate.\\n\\nI also find it unexpected and confusing that `ColumnsProvider` depends on `FiltersContext`. I would expect it the other way around. But you can decide whether you share this perspective.\\n\\nYou might also end up with cyclic dependency because, if you remember the initialization logic above, you know `FiltersProvider` depends on `ColumnsContext`.\\nSo we need to use constant for initializing filters instead, which creates a need to keep the initial value in sync too.\\n\\n<ul className=\\"list-none pl-2\\">\\n  <Pro>Better maintainability</Pro>\\n</ul>\\n<ul className=\\"list-none pl-2\\">\\n  <Con>Need for merging function</Con>\\n  <Con>Reverted dependency</Con>\\n  <Con>Cyclic dependency</Con>\\n</ul>\\n\\nIs there a better option?\\n\\n\\n\\n&nbsp;\\n\\n### 3. Effect Approach\\n\\nimport Attempt6Effect from \'./Example/Attempt6Effect\'\\n\\n<Attempt6Effect/>\\n\\n```tsx\\nconst [columns] = useContext(ColumnsCtx)\\nconst [setFilters] = useContext(FiltersCtx)\\nuseEffect(() => {\\n    setFilters(prevFilters =>\\n        mergeFilters(prevFilters, columns)\\n    );\\n});\\n```\\n\\nYou may think of `useEffect`. It can react to any change to columns state.\\nOops. Again, we need to use the `mergeFilters` function to avoid resetting all filters.\\n\\nBut there is a bigger problem. `useEffect` is not synchronous, and it does not run in the same render cycle.\\nSo when you add a new column, the filters are not updated immediately.\\nThere is a brief timeframe where your filters are not in sync with columns.\\n\\nIt can be a source of bugs and glitches.\\nThe UI jumps back and forth. It is visually disturbing and can break animations.\\n\\nBut more importantly, it causes a double refetch, leading to performance issues, unnecessary server load, and increased costs.\\nYou can see it by yourself in the interactive example above. Try to change visible columns and watch fired requests counter.\\n\\n<ul className=\\"list-none pl-2\\">\\n  <Pro>Good maintainability</Pro>\\n  <Pro>No weird dependencies</Pro>\\n</ul>\\n<ul className=\\"list-none pl-2\\">\\n  <Con>Asynchronous update</Con>\\n  <Con>UI glitches</Con>\\n  <Con>Doubled fetching</Con>\\n  <Con>Need for merging function</Con>\\n</ul>\\n\\nDo not use `useEffect` for synchronizing states.\\n\\n\\n\\n&nbsp;\\n\\n### 4. Selector Approach\\n\\nimport Attempt7Selector from \'./Example/Attempt7Selector\'\\n\\n<Attempt7Selector/>\\n\\n```tsx\\nfunction useFilters() {\\n  const [attributes] = useContext(AttributesCtx)\\n  const [filters] = useContext(FiltersCtx)\\n  return attributes.map((attribute) => {\\n    const filter = filters[attribute]\\n    return { attribute, ...filter }\\n  })\\n}\\n```\\n\\n```tsx\\ntype Filters = {\\n    [attribute: string]: {\\n        operator?: \'=\'|\'>\'|\'<\',\\n        value?: string|number\\n    }   \\n}\\n```\\n\\nWhat you encountered is a problem with state synchronization caused by duplicate state.\\nFilters and columns are different entities, but part of their state is duplicated and can be shared.\\nIt\u2019s about visible attributes. So we extract the visible attributes from both states and derive visible columns and filters from them.\\nLet\u2019s step into a time machine and go back to 2027, where we were shaping filters state.\\n\\nWe want to change the semantics of the filters state. It will not hold which filters are visible but just which attributes are filtered.\\nWe adjust the shape of the filters and make it a dictionary.\\nThe `useFilters` hook will merge two states: visible attributes and modified filters.\\nThe benefit is that we do not have to initialize the state at all.\\nSince columns don\u2019t contain any additional state beyond attributes, we can use attributes directly in the same manner as columns before (this is not always the case, but let\u2019s keep this example simple).\\n\\n![State Synchronization Selector Approach Diagram](./avoid-state-sync-trap-diagram.png)\\n\\nThis way, filters will always be the same as columns.\\nEven if the filters state is empty, there is no need for initialization.\\nThe change is synchronous. No glitches. No useless refetches.\\nColumns are independent of Filters.\\nThe column state can be updated in any way, and the reactivity system will take care of rerunning this derivation logic.\\n\\nYou might argue someone can forget to use this hook and access the filters state directly.\\nYou are right.\\nSo what\u2019s the advantage compared to the `setColumns` wrapper function?\\nBut <abbr title=\\"In My Opinion\\">IMO</abbr>, it\u2019s less likely to happen since forgetting the hook would immediately result in an empty state.\\n\\nAlso, this derivation logic (selector) is easier to maintain than a setter (action) because it is reactive.\\nWe just focus on control logic, not when it should be called.\\nThe reactive system takes care of it.\\n\\nIt is fair to say that there is a hidden user experience difference.\\nWhen the attribute is filtered, then removed and added again, it holds the previous filter values.\\nTherefore, orders are filtered after the column is added back.\\nYou can try it by yourself in the interactive example above.\\n\\nSometimes this behavior is even desired, but in this situation it is unintuitive, and I see it as a disadvantage here.\\nIt is fixable by combining this selector approach with the previously mentioned gate setter approach.\\nSimply clear the selected filter whenever a column is removed.\\nHowever, I\u2019ll keep this article short and won\u2019t go into further detail here.\\nI see this as an edge-case, and I believe mentioned benefits outweigh this disadvantage.\\nBut feel free to make your own opinion here.\\n\\n<ul className=\\"list-none pl-2\\">\\n  <Pro>Good maintainability</Pro>\\n  <Pro>No weird dependencies</Pro>\\n  <Pro>Synchronous update</Pro>\\n  <Pro>No UI glitches</Pro>\\n  <Pro>Single fetch</Pro>\\n</ul>\\n<ul className=\\"list-none pl-2\\">\\n  <Con>Overly persistent state</Con>\\n</ul>\\n\\n\\n\\n&nbsp;\\n\\n## Conclusion\\n\\nIn 2027, we made a quite dangerous assumption: that columns and filters must be in sync.\\nIt is an invariant of your state shape, which TypeScript is not able to check. Therefore, you need to handle it manually.\\nThis was just one example inspired by a real-world problem. But I frequently see developers using effects and setters to synchronize states.\\nSelectors generally provide more maintainable solutions, are synchronous, and ensure immediate, predictable updates.\\n\\n<abbr title=\\"In My Opinion\\">IMO</abbr>, these state invariants represent a bad code smell.\\nThey frequently cause bugs, glitches, and performance issues.\\nTry to develop a nose for these invariants and pay attention when someone introduces one into your app.\\n\\nI know the world out there is wild. Perhaps your junior colleague has already created a shape like this, \\nand it\u2019s deeply baked into your app, leaving no time to refactor the entire codebase.\\nIn such a case, I would recommend going with the gate setter solution.\\nDefinitely avoid `useEffect` if possible.\\nAdditionally, consider implementing a function that checks invariants that must always hold true for your state.\\nYou can run this function within your derivation logic (selectors) to alert you immediately if an invariant breaks.\\n\\nI hope I\u2019ve given you some material to think about. As always, if you disagree with me, I encourage you to get in touch. In any case\u2026\\n\\nThanks for reading.\\n\\n\\n\\nimport Discuss from \'@site/components/Discuss\'\\n\\n<Discuss\\n    twitter=\\"https://x.com/ondrejvelisek/status/1911856456489681207\\"\\n    li=\\"https://www.linkedin.com/posts/ondrej-velisek_avoid-the-state-synchronization-trap-ondrej-activity-7317623391673307137-Pl4z/\\"\\n    bsky=\\"https://bsky.app/profile/ondrejvelisek.bsky.social/post/3lmsaw4qky22u\\"\\n    />\\n\\n&nbsp;"},{"id":"how-nextjs-breaks-react-fundamentals","metadata":{"permalink":"/how-nextjs-breaks-react-fundamentals","source":"@site/blog/2024-03-19-how-nextjs-breaks-react-fundamentals/index.mdx","title":"How Next.js breaks React Fundamentals (Examples)","description":"In the front-end world, there\'s an ongoing war over performance.","date":"2024-03-19T00:00:00.000Z","tags":[],"readingTime":13.05,"hasTruncateMarker":true,"authors":[],"frontMatter":{"slug":"how-nextjs-breaks-react-fundamentals","image":"./rendering-runtime.png","draft":false},"unlisted":false,"prevItem":{"title":"Avoid the State Synchronization Trap","permalink":"/avoid-state-synchronization-trap"},"nextItem":{"title":"Conceptual Model of React and RSC","permalink":"/conceptual-model-of-react-and-rsc"}},"content":"In the front-end world, there\'s an ongoing war over performance.\\nRSC (React Server Components), currently implemented in the Next.js App router, serve as the official weapon aimed at improving startup performance.\\nHowever, it seems that in the midst of this battle, we\'ve forgotten about some fundamentals, resulting in a degraded DX (Developer Experience).\\nThis article aims to provide examples of such DX issues in the current Next.js API.\\nTowards the end, I outline a better proposal.\\n\\n{/* truncate */}\\n\\nI want to make it explicitly clear that it\'s not my intention to blame, dishonor, or offend React and Next.js maintainers.\\nI have respect for each one of them and appreciate their work. Thank you for your contributions.\\nHowever, at the same time, I want to present what I believe is wrong about the current API design in a clear and constructive manner.\\nThis way, we can foster a discussion based on specific examples.\\n\\nThis article loosely follows on from my previous piece, [Conceptual Model of React and RSC](/conceptual-model-of-react-and-rsc).\\nReading it beforehand will provide better context for the following text, which I highly recommend.\\n\\n\\n\\n\\n\\n\\n## DX > Performance\\n\\nFirst of all, let me defend the idea that <abbr title=\\"Developer Experience\\">DX</abbr> is more important than performance in terms of framework API design.\\n\\nWhat do I, as an app developer, do when a change requirement arrives?\\nI throw some nasty components on a screen and start crafting.\\nI add basic visuals, connect real data, make it interactive, improve styles, add loading, error, and empty UI, write tests, refactor component structure, solve bugs, optimize performance.\\n\\nI usually do it in this order. I\'m sure each of us prefers a different order. Some do <abbr title=\\"Test Driven Development\\">TTD</abbr>,\\nsome like to start with a pixel-perfect design with mockup data. It\'s okay.\\nHowever, no devs I know care about performance at first.\\nActually, some believe it is bad practice and should be avoided.\\nDonald E. Knuth believes \\"Premature optimization is the root of all evil.\\" or\\nMichael A. Jackson stated, \\"First rule of optimization: Don\'t do it.\\"\\n\\nTo be crystal clear: I\'m not trying to convince you to not take a performance-first approach.\\nI\'m trying to convince you that many developers do not optimize at first. And it works well for us.\\nA general-purpose framework should, at least, support, but better embrace this flow.\\nFast delivery supported by great <abbr title=\\"Developer Experience\\">DX</abbr> with the best possible performance out-of-the-box.\\nThen provide easy optimization tooling like refactoring patterns, optimizer hinting, more aggressive caching config, etc.\\n\\nPersonally, I\'m okay if a framework brings some syntax overhead due to performance optimization.\\nBut it is unacceptable for me to hurt the clear conceptual model and fundamental principles.\\n\\n\\n\\n\\n\\n\\n## Fundamentals\\n\\nIn the [previous article](/conceptual-model-of-react-and-rsc/), I described a set of fundamental properties I believe any front-end framework should follow to provide a good <abbr title=\\"Developer Experience\\">DX</abbr>. Let\'s quickly recap them.\\n\\n\\n1. **Composable** - Or Homogeneity. The ability to compose components into the full UI.\\n   Ability to place any component into any other component without changing its behavior.\\n\\n2. **Reusable** - The ability to define a name and reuse a component in a different place. Also, it involves passing arbitrary configuration (possibly reactive state) to adjust its behavior (props).\\n\\n3. **Colocated** - The ability to place all dependencies inside a component: name, render logic, necessary state connections, state derivation logic, styling, documentation, etc. If this is not met, developers have to jump back and forth in a codebase.\\n\\n4. **Encapsulated** - The ability to work on a component independently. All paths to affect the component from outside should be blocked by default. Breaking the barrier, for example, by exposing props, should be an opt-in feature. If this is not met, developers must mentally consider other code pieces.\\n\\n5. **Reactive** - A component must react to the connected state chosen by the developer. Any component must be able to connect to any state, and the same applies to derivation hooks. If certain rules are required, development becomes jammed.\\n\\n6. **Arbitrary** - The component\'s boundaries must obey the developer\'s needs. Nothing must force a component to split or not to split, as it would destroy its purpose.\\n\\nIt seems to me that Next\'s implementation of <abbr title=\\"React Server Components\\">RSC</abbr> breaks some of these fundamental properties due to their performance-first design. Examples follow now.\\n\\n\\n\\n\\n\\n## Sample Component\\n\\nImagine a requirement to create a page with a random quote about programming on each page refresh. Quotes are saved in a remote database.\\nHow would you implement it in the Next.js App router?\\n\\nNext.js [data fetching docs](https://nextjs.org/docs/app/building-your-application/data-fetching/fetching-caching-and-revalidating)\\nsuggest a simple async-await function within the component render function.\\nLet\'s assume we have the `random(from, to)` lodash-like function for brevity.\\n\\n```tsx\\nasync function ProgrammingQuotes() {\\n    // Here I want to connect to the external database state of quotes \\n    const quotes = await fetch(\'/quotes\')\\n    // Here I want to connect to a random number state\\n    const index = random(0, quotes.length)\\n    return <div>{quotes[index]}</div>\\n}\\n```\\n\\nJust place it somewhere on a page and we\'re done. Excellent <abbr title=\\"Developer Experience\\">DX</abbr> so far.\\nIt\'s a server-only component by default. Resulting in a small bundle, no client-server round trips,\\ngreat <abbr title=\\"First Contentful Paint\\">FCP</abbr> and <abbr title=\\"Largest Contentful Paint\\">LCP</abbr>,\\nNo <abbr title=\\"Cumulative Layout Shift\\">CLS</abbr>. Awesome startup performance as promised.\\n\\n\\n\\n\\n\\n## 1. Forced to Lift State up\\n\\nImagine a change requirement. Our UX department likes the component and wants it in an existing comments feed modal.\\nThis modal is currently a client component. Somebody just wrote it as client because it needs some client-side state.\\n\\n```tsx\\n\'use client\'\\nasync function FeedModal() {\\n    const [open, setOpen] = useState(false)\\n    return <>\\n      <Button toggle={setOpen}>Show comments</Button>\\n      <Modal opened={opened} >\\n         <Feed/>\\n         // error-next-line\\n         <ProgrammingQuotes/>\\n      </Modal>\\n    </>\\n}\\n```\\n\\n...Oops. <mark class=\\"error\\">\\"Error: Client component can\'t be async\\"</mark>. What happened? `\'use client\'` makes all of its descendants client components.\\nBut our `ProgrammingQuotes` assumes it is a server component.\\nI see three options for how to solve it with current Next.js abilities.\\n\\na. **Use client-side** data fetching solutions like `tanstack-query`, `useSWC`, or the new `use` React API. This means giving up on RSC and its performance benefits. \\n\\nb. **Lift fetch up** into a first server ancestor. It is not enough to lift quotes fetching to `FeedModal`.\\n   We need to go higher and then drill the fetched quote data via props.\\n   The code **Colocation** property is torn apart.\\n\\nc. **Refactor modules** so `ProgrammingQuotes` is passed as children to `FeedModal`.\\n   However, it forces me to compose components in a certain way. It does not obey my needs and therefore breaks the **Arbitrary** boundary property.\\n   Furthermore, I\'m forced to expose a children prop. Which breaks the **Encapsulation** property.\\n\\nAll of the options have a negative impact on my work. Either on performance or worse project maintainability.\\n\\n\\n\\n\\n\\n\\n## 2. Forced to Split a Component\\n\\nImagine a change requirement. A quote is not random but should change every five seconds in the order received from a database.\\nA way to access some counting state is with `setInterval` so let\'s use it.\\nI would adjust our component like this:\\n\\n```tsx\\nasync function ProgrammingQuotes() {\\n    const quotes = await fetch(\'/quotes\')\\n    // highlight-next-line\\n    const index = useCounter(5000)\\n    return <div>{quotes[index]}</div>\\n}\\n\\nfunction useCounter(delay) {\\n    // This hook is simplified for brevity\\n    // error-next-line\\n    const [count, setCount] = useState(0)\\n    // error-next-line\\n    useEffect(() => setInterval(() => setCount(count + 1), delay))\\n    return count\\n}\\n```\\n\\n...Oops. <mark class=\\"error\\">\\"Error: Server component can\'t use \'useState\' and \'useEffect\' hooks\\"</mark>.\\nSince server components can\'t react to time changes (in other words, they can\'t reactively connect to time state), we need to use a client component.\\nSo maybe add `\\"use client\\"` to the top of the file?\\n...Oops. <mark class=\\"error\\">\\"Error: Client component can\'t be async\\"</mark>. What do we do?\\nI see the following options:\\n\\na. **Use client-side fetching**, but as stated above, we give up on <abbr title=\\"React Server Components\\">RSC</abbr> and their performance.\\n\\nb. **Lift fetch up**, but as stated, it breaks the code **Colocation**.\\n\\nc. **Split the component** into a server parent and a client child. The parent is async with `fetch`, and the child uses `useCounter`. However, we are actually forced to put them into separate file modules.\\n   So we end up with dislocated code. **Colocation** is broken anyway.\\n\\nAgain, I have no good choice. I have to sacrifice.\\nAt this point, let me remind you of a talk about the importance of colocation\\nby Dan Abramov in his [Introduction of hooks (YouTube)](https://www.youtube.com/watch?v=dpw9EHDh2bM&t=2600s).\\n\\n\\n\\n\\n\\n\\n## 3. Forced to Prop Drilling\\n\\nImagine a change requirement. We want to add quotes filtered by author. The author is placed in the URL query param, so it can be shared, and only quotes of such author appear.\\nAfter the previous example, we end up with two components.\\n\\n```tsx\\nasync function ProgrammingQuotesServer() {\\n    // Here I want to connect to the URL query param state\\n    // error-next-line\\n    const author = useSearchParam(\'author\');\\n    const quotes = await fetch(`/quotes?author=${author}`)\\n    return <ProgrammingQuotesClient quotes={quotes}/>\\n}\\n```\\n```tsx\\n\'use client\'\\nasync function ProgrammingQuotesClient({ quotes }) {\\n    const index = useCounter(5000)\\n    return <div>{quotes[index]}</div>\\n}\\n```\\n\\n[Next.js docs](https://nextjs.org/docs/app/api-reference/functions/use-search-params#server-components)\\nsuggest `useSearchParam` hook or `searchParams` props.\\n\\nSo let\'s try `useSearchParam` first.\\n...Oops. <mark class=\\"error\\">\\"Error: Server component can\'t use \'useSearchParam\' hook\\"</mark>\\nOkay. `searchParams` prop will help. ...Oops. This prop is accessible only in the top-level page component.\\nI see the following options:\\n\\na. **Use client-side fetching** means no RSC benefits.\\n\\nb. **Drill props** down from the top-level page. In large apps with a deep component tree, this is unmaintainable.\\n\\nc. **Create context** for URL params and then access it with `useContext` from the server component. Uf, a lot of work for such a basic use-case.\\n   But it\'s solved, and I can reuse this context for all other URL params and all components, right?\\n\\n\\n\\n\\n\\n\\n## 4. Forced to Give up on Server\\n\\nImagine a last change requirement. This little component should be moved to a footer component. The footer is in a page layout component tree.\\n...Oops. `searchParams` prop is inaccessible in layouts. What do I do? It\'s very frustrating, but it seems I need to refactor and convert it to a client component to be able to use `useSearchParam`.\\n...Oops. <mark class=\\"error\\">\\"Error: Client component can\'t be async\\"</mark>.\\nAm I just being forced to choose between server-side fetching or Next.js layouts feature?\\n\\n\\n\\n\\n\\n## Summary\\n\\nThose simple examples break most of the defined rules.\\nThe `ProgrammingQuotes` component can\'t be easily reused in a modal or footer.\\nIts code is dislocated into several modules.\\nThe author search query is inaccessible from the component itself.\\nI\'m forced to expose children as a component prop\\nand create artificial Client and Server components.\\n\\nI want to emphasize that these examples are not some edge-case nonsense. Similar requirements come up every day.\\nI\'m 100% sure that at least one example has happened to every developer who creates some non-trivial app in the Next.js App router.\\nI truly believe Colocation, Encapsulation, and Arbitrary composition are crucial properties for efficient development.\\nThey are necessary for team cooperation and maintaining mid-large codebases.\\nEspecially for long-term projects with many change requirements over the years where many developers read and manipulate the code and need to quickly understand what is happening.\\nThat\'s the reason I\'m writing this. So we can design better framework APIs.\\n\\nMany of you argue that I can use the old client-side approach and then gradually move to the server.\\nStart with a full client-side app and if performance is needed, push the client boundary down through a component tree.\\nYou are smart.\\nI see three catches. 1. this is not recommended nor mentioned by the Next.js team. 2. <abbr title=\\"In My Opinion\\">IMO</abbr> is too much work.\\nBoth, writing but more importantly mental.\\nIt is not just putting `\'use client\'` at the top of the module, but also modifying async code, using different methods to access URLs, refactor component boundaries and more.\\n3. I believe there is a way to provide better out-of-the-box performance without compromising on DX.\\nAnd still keep the ability to achieve the same performance as current Next.js with an easier optimization path.\\n\\n\\n\\n\\n\\n\\n## A Better Approach\\n\\nIn Next.js implementation of RSC, we define if a component is server or client at the module level.\\nIf the compiler sees `\'use client\'`, the code is bundled and shipped to the client. It stays server-only otherwise.\\nIn other words, we are choosing where a component is rendered, respectively its runtime environment.\\nThis component runtime then limits its capabilities, e.g., using async fetching or client state.\\n\\nThe last example with layouts limits component capabilities based on a module too.\\nIf the compiler sees a file named `layout.tsx`, its components are considered \\"more static\\".\\nSome more dynamic state like search params can\'t be used.\\n\\nI believe <mark>component capabilities should never be limited by a module-level configuration</mark>.\\nAny component must be capable of using any feature. <mark>Where rendered and when re-rendered should be deduced automatically</mark>\\nby features used within the component.\\n\\nBoth runtime environment and re-rendering frequency are unrelated to my business goals. \\nIdeally, it is an implementation detail and a framework should shield me from it.\\nThe best-performing strategy should be chosen by the framework automatically.\\nIt is the same as how re-rendering works on the client nowadays. Developers use some state within a component, and it re-renders when the state changes.\\nNo manual tweaking of shouldComponentUpdate. The same applies to signals.\\n\\nParadoxically, Next.js inspired me with this idea.\\nIt chooses between build and request-time rendering based on [Dynamic functions](https://nextjs.org/docs/app/building-your-application/rendering/server-components#dynamic-functions)\\nused within the component.\\nFor [some reason](https://nextjs.org/docs/app/api-reference/file-conventions/layout#layouts-do-not-receive-searchparams), they limit this deduction in layouts.\\nI believe this automatic deduction concept should be used more broadly.\\n\\n![Components runtime environment rendering diagram](./rendering-runtime.png)\\n<p style={{ textAlign: `center` }}>*Components go through runtimes and if some state is needed, they re-render. Pass the runtime otherwise.*</p>\\n\\nIn the end, let\'s think together about this algorithm of automatic runtime environment deduction.\\nFirst of all, what environments do we have available, respectively where could the component be rendered?\\nFor sure on a client in a browser. Also on a server. We should distinguish between static rendering during build and dynamic rendering during server request.\\nThere are more flavors, like edge runtime or <abbr title=\\"Deferred Static Generation\\">DSG</abbr>, but let\'s stick with just those three for now.\\nLet\'s sort them by performance. For most cases, it is like this: Build, Server, Client.\\nI want to choose the most performant automatically if nothing forces me otherwise.\\n\\nWhat forces a component to use a less performant runtime? It is when a component needs some more dynamic or interactive features, respectively connects to some kind of dynamic or interactive state.\\nWhen a component connects to `searchParam`, `cookie`, or `headers`, those states are not known during build-time and it must be rendered during server request.\\nThis is what Next.js does with dynamic functions I mentioned above.\\nSimilarly, when a component connects to `useState`, `setInterval`, or `onMouseEnter`, it must be rendered on the client because those states are not accessible on the server.\\n\\nI hope your head is screaming now \\"But Ondrej, it would not work! Bundling is a compile-time feature!\\".\\nIf so, I\'ve done a good job explaining my thoughts. Congratulations. You understand the concept correctly.\\nThere are many questions to be answered.\\nWhat if a callback function is passed to a component as a prop?\\nAre there situations a component is rendered in multiple runtimes?\\nMany details are unresolved. But let\'s stop here.\\n\\nI plan to write a following article where I dive into the API of a new fictional framework and also touch some implementation possibilities.\\nUntil then, I invite you to think about its DX benefits and how you would implement it. Try to think how and not why can\'t.\\nAnd let me know what you think.\\n\\nThanks for reading.\\n\\n\\n\\nimport Discuss from \'@site/components/Discuss\'\\n\\n<Discuss\\n    twitter=\\"https://x.com/search?q=https%3A%2F%2Fondrejvelisek.github.io%2Fhow-nextjs-breaks-react-fundamentals%2F\\"\\n    reddit=\\"https://www.reddit.com/r/nextjs/comments/1bipvwe/how_nextjs_breaks_react_fundamentals_with_examples/\\"\\n    dev=\\"https://dev.to/ondrejvelisek/how-nextjs-breaks-react-fundamentals-with-examples-2lof\\"\\n    />"},{"id":"conceptual-model-of-react-and-rsc","metadata":{"permalink":"/conceptual-model-of-react-and-rsc","source":"@site/blog/2024-03-03-conceptual-model-of-react-and-rsc/index.mdx","title":"Conceptual Model of React and RSC","description":"Building web apps is a complex problem. We need simple high-level mental structures to support such a heavy load.","date":"2024-03-03T00:00:00.000Z","tags":[],"readingTime":8.985,"hasTruncateMarker":true,"authors":[],"frontMatter":{"slug":"conceptual-model-of-react-and-rsc","image":"./holistic-state.png","draft":false},"unlisted":false,"prevItem":{"title":"How Next.js breaks React Fundamentals (Examples)","permalink":"/how-nextjs-breaks-react-fundamentals"},"nextItem":{"title":"Practical limits of React hooks - Recursion","permalink":"/practical-limits-of-react-hooks-recursion"}},"content":"Building web apps is a complex problem. We need simple high-level mental structures to support such a heavy load.\\nThese structures allow us to offload unnecessary details from our brains, so we can focus on the important parts of our code.\\n`UI = f(state)` is one of them. Every one of us knows this formula. But do you know what it reflects in the real world?\\nWhat is `UI`? What is `state`? What the f* is *`f`*? And how is it affected by RSC (React Server Components)? Here is my view.\\n\\n{/* truncate */}\\n\\n![Holistic state philosophy](./holistic-state.png)\\n\\nInitial clarifications:\\n- I reckon the state mutates, but I ignore how it is mutated.\\n- I show examples of React, but most of the following applies to other UI frameworks like Angular, Vue, Svelte, Qwik, or Solid.\\n\\n\\n\\n## What is `state`?\\n\\nLet\'s reconsider: `UI = f(state)`. In other words, `state` is what our `UI` depends on. If a dependency changes, we want to change the `UI`. This phenomenon is called **reactivity**.\\n\\nI believe that state encompasses more than just in-memory local component state (`useState`) or in-memory global app state (Redux, Jotai, Zustand).\\nI\'m not alone (\\n[TkDodo](https://tkdodo.eu/blog/react-query-as-a-state-manager),\\n[ByteGrad (YouTube)](https://www.youtube.com/watch?v=ukpgxEemXsk),\\n[Kent C. Dodds](https://x.com/kentcdodds/status/1349173470567964673),\\n[Dave Rupert](https://daverupert.com/2024/02/ui-states/),\\n[Dan Abramov](https://overreacted.io/the-two-reacts/)\\n). Many developers agree that at least the URL and server data constitute some kind of state too. But I believe it has a much wider scope.\\n\\nLet\'s consider some `UI` examples:\\n\\n- Blog post UI depends on the slug present in the **URL** address.\\n- Server files explorer UI depends on **server** files.\\n- The newest movies list UI relies on the **third-party** resource of OMDB. \\n- Ticking clock UI depends on **time**.\\n- Drawing canvas UI relies on the mouse position of the user\'s **input device**.\\n- User profile UI depends on the session token stored in a **cookie**.\\n- The \\"Keep me signed in on this device\\" UI depends on a flag in **local storage**.\\n- OS preferred dark mode UI depends on the **OS setting**.\\n- Devtools debug UI depends on an **env variable**.\\n- Panoramic background UI depends on the scroll position of a **DOM** element.\\n- ... Got the idea?\\n\\nI refer to these states as **source states**. It\'s important to note that a state may be *derived*. For example:\\n\\n- The current post *slug* depends on the **URL**.\\n- The current post *minutes read* depends on the *slug* and **server files**.\\n- The current *user role* depends on authorization data in the **server database** and the session token from the **cookie**.\\n- The *preferred dark mode* depends on **local storage** and the **OS setting** (storage as user preference and OS as default).\\n- The minutes value in a pausable stopwatch depends on **time** and the spacebar **pressed key**.\\n- ... Ok. You got it.\\n\\nDerived state depends on another state and should change when its dependencies change. In other words, it should be reactive. You can find a great deep-dive into this topic on [React Training - Derived State](https://reacttraining.com/blog/derived-state).\\n\\nThe boundary between **source** and *derived* states is blurry. For example, the server database, local storage, OS settings, all of those depend on file system data.\\nBut let\'s mark state as \\"source\\" when it depends solely on states inaccessible by available technologies. For example, I can\'t access some private browser file with local storage data from the browser window environment.\\n\\nI would like to be explicit and distinguish between in-memory state and all those kinds of states.\\nFor myself, I name it a **Holistic state**.\\n\\n\\n\\n## What is `UI`?\\n\\nIt is what users perceive with their senses, usually with their eyes on the screen. On the web, it is represented with the **DOM**.\\n\\nThe wilderness out there is more diverse.\\nOur user might be a machine like a search indexing bot, but they also work on DOM elements and attributes.\\nThere could be assistive technologies like a screen reader, working on the DOM as well.\\nA very important piece of UI is the URL in the browser address bar. Since it is always in sync with the URL state, I like to think about it as a source state rather than UI. \\nUsers also perceive playing sounds, haptic vibration feedback, flashlight, etc.\\nLet\'s simplify and stick with DOM only. It\'s worth mentioning that the following applies to other UI pieces similarly.\\n\\nAs a developer, I expect the framework to provide tools to describe UI and update the DOM when the description changes.\\nIn React and Vue, those tools are JSX and VDOM. In Solid, it is a signal dependency graph.\\n\\nNote: I classified DOM as both UI and source state. If we use DOM as a source state and let our UI depend on it, we create a cyclic dependency.\\nSometimes it is necessary, e.g., when measuring text width. Be careful in such situations to not create infinite loops. The same applies to the URL.\\n\\n\\n\\n\\n## What the f* is *`f`*?\\n\\n*`f`* is something that connects `state` and `UI`.\\nYou may say it is the component tree with its render function. And you are <abbr title=\\"In My Opinion\\">IMO</abbr> partially right. \\n\\nBecause this *`f`* function usually produces many UI pieces,\\nit is a \\"necessity\\" to split the mental load into reusable smaller `f`s - components.\\n[Dan Abramov](https://overreacted.io/a-chain-reaction/) wrote a great article about it.\\n\\nReact component ergonomics example:\\n```tsx\\nfunction Post(slug) {                  // name and state received via props\\n    const posts = useQuery(fetchPosts) // state received via hook\\n    const post = posts[slug]           // derivation logic\\n    return <div>{post}</div>           // JSX UI description\\n}\\n```\\n\\n- **Name** of the function to be referenceable.\\n- **Receive state** via props or hooks (or higher-order components).\\n- **Derive state** before JSX is produced. Right within the render function or separated into a custom function.\\n- **Produce UI description** in the form of JSX which is then consumed by VDOM.\\n\\nI said partially. Components do not (usually) directly connect to states. They just receive a value/connection.\\n\\n\\n\\n\\n## Connecting States\\n\\nWe need a way to choose the states upon which our component depends. We want to subscribe/observe changes and execute derivation and rendering logic with new values.\\n\\nHooks do an excellent job with their smart `useEffect` and `useRef`. Much maligned for their ergonomics, but in my opinion, they get the conceptual job right. Let\'s refer to custom hooks using `useEffect` and `useRef` as **connecting hooks**.\\n\\nReact connecting hook ergonomics example:\\n```tsx\\n// name and config received via props\\nfucntion useStopwatch(delay) {          \\n    const [ticks, setTicks] = useState(0)\\n    useEffect(() => {         \\n        // subscribing to real world state (time)            \\n        const timer = setInterval(() => setTicks(prev => prev + 1), delay)\\n        return () => clearInterval(timer)\\n    }, [delay])\\n    // Returning reactive state\\n    return ticks                          \\n}\\n```\\n\\nMany libraries like `tanstack-query` for external resources, `react-router` for URLs, or `react-use` for various kinds of states have been created. They allow us (app devs) to connect to the source state with just one line of code from within the component. And don\'t care much about how. Great abstraction.\\n\\nThese connecting hooks are the missing glue between state and component rendering logic. They subscribe to state changes and rerun the necessary derivation and rendering logic accordingly.\\n\\nIn my opinion, the observer pattern is best for developer experience (DX). But sometimes it is not possible or desired, usually for performance reasons. Typically, this is the case for states far away from the client, like server data. Even for them, we have mechanisms like websockets or long polling. But usually, we fall back to the initial fetch during either component mount, server request, or build. Then caching, invalidation, and optimistic update mechanisms must come into play. But let\'s still call them connecting hooks anyway.\\n\\nThere are hooks that create state themselves, like `useState` and `useReducer`, and simultaneously connect to it. But let\'s stick with the word \\"connecting\\" only.\\n\\n\\n\\n## Developer Experience\\n\\nSo the real-world picture of `UI = f(state)` for app developers could be condensed into:\\n```js\\nDOM = render(derive(connect(holistic_state)))\\n```\\n\\nIt is a super simple mental model for such a complex problem as a web app. It is **conceptually clean and mentally relieving**. Modern client-side <abbr title=\\"Single Page Application\\">SPA</abbr>s follow this conceptual model quite precisely. I believe many devs love React 16.8+ (hooks introduced) because of this mental model, myself included. It speeds up development, saves time, and money.\\n\\nBut for the model to be helpful, some additional properties must be met:\\n\\n1. **Composable** - Ability to compose components into the full UI.<br/>\\n   Ability to <mark>place any component into any other component</mark>.\\n\\n2. **Reusable** - Ability to define a name and reuse a component in a different place.<br/>\\n   Also, the ability to pass arbitrary configuration (possibly reactive state) to adjust its behavior (props).\\n\\n3. **Colocated** - Name, render logic, necessary state connections, state derivation logic, documentation, etc.<br/>\\n   Devs should be able to <mark>place all those dependencies inside a component</mark>.<br/>\\n   If not, devs jump back and forth in a codebase. Inconvenient.\\n\\n4. **Encapsulated** - Ability to work on a component independently by default. Opt-in to break the barrier.<br/>\\n   If not met, devs must mentally think about other code pieces.\\n   Note: this is broken by React cascading memoization. Frustrating.\\n\\n5. **Reactive** - Component must react to connected state the dev chooses.<br/>\\n   <mark>Any component must be able to connect to any state</mark>. The same applies for derivation hooks.<br/>\\n   If some rules are required, it makes development jammed.\\n\\n6. **Arbitrary** - The component\'s boundaries must obey the dev\'s needs.<br/>\\n   <mark>Nothing must force a component to split (or not to split)</mark>.<br/>\\n   Same for derivation hooks. It destroys their purpose otherwise.\\n\\nWhy does all of this matter? Because the conceptual model needs to be solid. All the time. If we develop some complex logic with those principles in mind, it can\'t happen due to broken principles that we need to refactor. I want to trust it will support me during heavy loads.\\n\\nI can handle some configuration and syntax overhead like useEffect, CSS integration, or Webpack. I\'m fine to write a few extra chars if the conceptual model stays clear.\\n\\nI know React client <abbr title=\\"Single Page Application\\">SPA</abbr>s suffer from bad performance. I believe that the conceptual model is so important; it should not be broken by enforcing good performance patterns. The framework should remain loyal to the clear model and do its best for performance. In addition, provide tools to optimize like optimization hints, refactoring patterns, or more aggressive caching config.\\n\\nIt seems to me <abbr title=\\"React Server Components\\">RSC</abbr> and NextJS just <mark>break some fundamental properties of this conceptual model</mark> because of their performance-first design. And I believe it is not necessary to achieve their goals. But let\'s stop here and keep this for the next article.\\n\\n> UPDATE: follow-up article [How Next.js breaks React Fundamentals (Examples)](/how-nextjs-breaks-react-fundamentals/) is out.\\n\\nThanks for reading.\\n\\n\\n\\nimport Discuss from \'@site/components/Discuss\'\\n\\n<Discuss\\n    twitter=\\"https://x.com/search?q=https%3A%2F%2Fondrejvelisek.github.io%2Fconceptual-model-of-react-and-rsc%2F\\"\\n    reddit=\\"https://www.reddit.com/r/reactjs/comments/1b6eowb/conceptual_model_of_react_in_the_rsc_age/\\"\\n    dev=\\"https://dev.to/ondrejvelisek/conceptual-model-of-react-in-the-rsc-age-5bn5\\"\\n    />"},{"id":"practical-limits-of-react-hooks-recursion","metadata":{"permalink":"/practical-limits-of-react-hooks-recursion","source":"@site/blog/2022-03-23-practical-limits-of-react-hooks-recursion/index.mdx","title":"Practical limits of React hooks - Recursion","description":"While ago, I started using React hooks. The simplicity, homogenity and composability sounded great.","date":"2022-03-23T00:00:00.000Z","tags":[],"readingTime":3.925,"hasTruncateMarker":true,"authors":[],"frontMatter":{"slug":"practical-limits-of-react-hooks-recursion","image":"./hook.png","draft":false},"unlisted":false,"prevItem":{"title":"Conceptual Model of React and RSC","permalink":"/conceptual-model-of-react-and-rsc"}},"content":"While ago, I started using React hooks. The simplicity, homogenity and composability sounded great.\\nBoth components and hooks are simple functions. I can easily react on state changes from memory, \\nlocal storage, location URL and server the same way - with hooks. Mental model stays simple.\\nMy app is just a big function which consumes state and produces DOM. This big function is composed \\nof a smaller functions which are composed of smaller functions and so on. But there were obstacles \\nI\'ve started to encounter and in the end I hit the hard limit of React hooks.\\n\\n{/* truncate */}\\n\\n> UPDATE 2024: new React [`use`](https://react.dev/reference/react/use) hook may finally solve following limitation \\n> (if you accept `<Suspense/>` as a good pattern)\\n\\n## Model app\\n\\nEach app has some data model defined with entities and relations between them. Lets say we have company \\nDepartment and Employee where department consists of other departments and/or direct employees. \\nOne employee can directly work for exactly one department. Cycles in department hierarchy are prohibited.\\n\\nOur Backend implements REST endpoints.\\n\\n```code title=\\"/departments\\"\\nreturns list of all department ids\\n```\\n\\n```code title=\\"/departments/:departmentId\\"\\nreturns list of sub-department ids\\nand list of direct employee ids\\n```\\n\\nThere are three product requirements.\\n\\n## Pleasant walk with basic hooks\\n\\nFirst product requirement is simple. User selects a department and wants to see number of direct employees.\\nPfff, its simple. Just implement this custom hook which uses department REST endpoint and use it in a component.\\n\\n```tsx\\nconst useDirectEmployeeCount(\\n    departmentId: string\\n): number =>\\n    useDirectEmployeeIds(departmentId).length\\n```\\n\\n```tsx\\nconst useDirectEmployeeIds(\\n    departmentId: string\\n): Array<string> =>\\n    useDepartment(departmentId).directEmployeeIds\\n```\\n\\n```tsx\\nconst useDepartment(\\n    departmentId: string\\n): Department =>\\n    useQuery(\\n        [\'departments\', departmentId],\\n        () => fetch(`/departments/${departmentId}`)\\n    ).data\\n```\\n\\nOur backend implements exactly this endpoints so we use `react-query` and we are done.\\nThere are some loading and error states which I omitted, we can use fancy Suspend and ErrorBoundary,\\nbut we understand the code.\\n\\n\\n## Obstacles with looping\\n\\nSecond product requirement is simple. User needs to select multiple departments and see sum of direct employees.\\nOk, simple. I already have code for one. So simply loop it over multiple selected departments and sum the result.\\n\\n```tsx\\nconst totalCount = sum(\\n    departmentIds.map(\\n        departmentId => useDirectEmployeeCount(departmentId)\\n    )\\n)\\n```\\n\\nWait! It is a hook and there are rule of hooks. Anoying but still doable.\\nLets reimplement `useDirectEmployeeCount` to support multiple department ids. \\nThen I can sum them like this.\\n\\n```tsx\\nconst departmentCounts = useDirectEmployeeCount(departmentIds)\\nconst totalCount = sum(departmentCounts)\\n```\\n```tsx\\nconst useDirectEmployeeCount(\\n    departmentIds: Array<string>\\n): Array<number> =>\\n    useDirectEmployeeIds(departmentIds)\\n        .map(employeeIds => employeeIds.length)\\n```\\n\\nBut wait! I need to reimplement `useDirectEmployeeIds` too. Very anoying.\\n\\n```tsx\\nconst useDirectEmployeeIds(\\n    departmentIds: Array<string>\\n): Array<Array<string>> =>\\n    useDepartment(departmentIds)\\n        .map(department => department.directEmployeeIds)\\n```\\n\\nBut wait! Grrr...\\n\\n```tsx\\nconst useDepartment(\\n    departmentIds: Array<string>\\n): Array<Department> =>\\n    useQueries(departmentIds.map(departmentId => ({\\n        queryKey: [\'departments\', departmentId],\\n        queryFn: () => fetch(`/departments/${departmentId}`)\\n    })))\\n        .map(result => result.data)\\n```\\n\\nUf. Done. I\'m glad it is a small project with just three hooks. Tell me the last requirement.\\n\\n## Limits with recursion\\n\\nThird and last product requirement is simple. User needs to select department and see sum of direct and\\nindirect employees (including employees from all sub-departments and their sub-departments and so on).\\nOk, simple. I already have code for multiple departments. So simply recursively call it and sum the result.\\n\\n```tsx\\nconst useIndirectEmployeeCount(\\n    departmentIds: Array<string>\\n): Array<number> => {\\n    const directCount = useDirectEmployeeCount(departmentIds);\\n    const departments = useDepartment(departmentIds);\\n    const subDepartmentIds = departments.flatMap(department => department.subDepartmentIds);\\n    const indirectCount = useIndirectEmployeeCount(subDepartmentIds);\\n    return directCount + indirectCount\\n}\\n```\\n\\nWait.\\n\\n> <mark class=\\"error\\">Error: Maximum Call Stack Size Exceeded</mark>\\n\\nOh. You almost got me. I just forgot a recursive break, right?\\n\\n```tsx\\nconst useIndirectEmployeeCount(\\n    departmentIds: Array<string>\\n): Array<number> => {\\n    const directCount = useDirectEmployeeCount(departmentIds);\\n    const departments = useDepartment(departmentIds);\\n    const subDepartmentIds = departments.flatMap(department => department.subDepartmentIds);\\n    if (subDepartmentIds.length === 0) {\\n        return directCount;\\n    }\\n    const indirectCount = useIndirectEmployeeCount(subDepartmentIds);\\n    return directCount + indirectCount\\n}\\n```\\n\\nWait.\\n\\n> <mark class=\\"error\\">Error: React Hook \\"useIndirectEmployeeCount\\" is called conditionally.</mark>\\n\\n...\\n\\n## Last words\\n\\nMental model stays simple. Everything is a simple function. My app is one big function composed of smaller and\\nsmaller ones. It trully sounds great! But in a real world, hooks are not so simple, homogen and composable.\\nThere are obstacles and limits mainly because of rule of hooks.\\n\\nThis post is not about saying React hooks are bad. I wrote it because I did not find any resources\\non such obstacles and limits. The React world looks like hooks are always pleasant walk trought the rosy garden.\\nBut they are not.\\n\\nFor now I don\'t know how to elegantly solve the recusrion example. Are there some resources on this?\\nDo you have following thougts? Maybe I\'m not the only one struggling.\\n\\nThanks for reading.\\n\\n\\n\\nimport Discuss from \'@site/components/Discuss\'\\n\\n<Discuss\\n    twitter=\\"https://x.com/search?q=https%3A%2F%2Fondrejvelisek.github.io%2Fpractical-limits-of-react-hooks-recursion%2F\\"\\n    reddit=\\"https://www.reddit.com/r/reactjs/comments/tkog71/practical_limits_of_react_hooks_recursion/\\"\\n    dev=\\"https://dev.to/ondrejvelisek/practical-limits-of-react-hooks-recursion-555\\"\\n    />"}]}}')}}]);