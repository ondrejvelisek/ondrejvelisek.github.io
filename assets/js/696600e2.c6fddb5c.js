"use strict";(self.webpackChunk_torrta_docs=self.webpackChunk_torrta_docs||[]).push([[985],{1350:(e,t,n)=>{n.d(t,{CU:()=>o,Kf:()=>i,LG:()=>l,Pl:()=>a,eB:()=>c});var s=n(5105);const r=20;function i(e){return(0,s.jsx)("div",{className:"flex flex-col w-full rounded-md p-4 bg-[#212432] mb-4",children:e.children})}function a(e){return(0,s.jsx)("div",{className:"relative h-8",children:e.children})}function o(e){return(0,s.jsxs)("div",{className:"text-sm px-2 pb-11 first:pb-2 pt-1 -mt-1 border-l border-0 border-slate-600 border-dashed absolute w-fit",style:{left:e.start*(100/r)+"%"},children:[e.title," ",(0,s.jsx)("span",{className:"text-slate-500",children:"\u2192"})]})}function l(e){const t=e.end?` ${e.end}`:"";return(0,s.jsxs)("div",{className:"flex relative items-center text-sm text-slate-500",style:{left:e.start*(100/r)+"%"},children:[e.children,t]})}const d={network:{color:"#0ea5e9",title:"Network",description:"Network from server to client (HTML & data)"},server:{color:"#f87171",title:"Server",description:"Server processing & rendering (request handling & SSR)"},client:{color:"#4ade80",title:"Client",description:"Client rendering & processing (browser)"},fetch:{color:"#fde047",title:"Fetch",description:"Fetching data on server (data from database)"}};function c(e){const{color:t,title:n,description:i}=d[e.type];return(0,s.jsx)("div",{className:"-mt-px flex items-center justify-start border border-r-0 first:border-l last:border-r  border-solid relative p-2 first:rounded-bl last:rounded-r last:mr-2 group-first:first:rounded-tl group-first:first:rounded-bl",style:{width:e.duration*(100/r)+"%",borderColor:`color-mix(in srgb, ${t}, transparent 40%)`,backgroundColor:`color-mix(in srgb, ${t}, transparent 80%)`,height:"100%",color:`color-mix(in srgb, ${t}, white 60%)`},title:e.description??i,children:(0,s.jsx)("div",{className:"text-sm truncate",children:e.title??n})})}},1874:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>g,contentTitle:()=>m,default:()=>y,frontMatter:()=>u,metadata:()=>s,toc:()=>j});var s=n(8730),r=n(5105),i=n(3331),a=(n(3742),n(9013)),o=n(8182),l=n(1350),d=n(2961),c=n(4116),h=n(8101);function p({id:e,host:t,repo:s,repoId:i,category:a,categoryId:o,mapping:l,term:d,strict:c,reactionsEnabled:p,emitMetadata:x,inputPosition:u,theme:m,lang:g,loading:j}){const[f,y]=(0,h.useState)(!1);return(0,h.useEffect)((()=>{f||n.e(440).then(n.bind(n,3440)).then((()=>y(!0)))}),[]),f?(0,r.jsx)("giscus-widget",{id:e,host:t,repo:s,repoid:i,category:a,categoryid:o,mapping:l,term:d,strict:c,reactionsenabled:p,emitmetadata:x,inputposition:u,theme:m,lang:g,loading:j}):null}function x(){return(0,r.jsx)("div",{className:"mt-20",children:(0,r.jsx)(p,{repo:"ondrejvelisek/ondrejvelisek.github.io",repoId:"R_kgDOLX0ymw",category:"General",categoryId:"DIC_kwDOLX0ym84CdyZe",mapping:"title",strict:"0",reactionsEnabled:"0",emitMetadata:"0",inputPosition:"bottom",theme:"transparent_dark",lang:"en",loading:"eager"})})}const u={slug:"tanstack-start-new-competitor-to-nextjs",image:"./tanstack-start-new-competitor-to-nextjs.png",draft:!1,unlisted:!1},m="TanStack Start: New competitor to Next.js",g={image:n(7137).A,authorsImageUrls:[]},j=[{value:"What do I compare?",id:"what-do-i-compare",level:2},{value:"Routing",id:"routing",level:2},{value:"Route definition",id:"route-definition",level:3},{value:"Page config",id:"page-config",level:3},{value:"Router typesafety",id:"router-typesafety",level:3},{value:"Data fetching",id:"data-fetching",level:2},{value:"Collocation",id:"collocation",level:3},{value:"Streaming",id:"streaming",level:3},{value:"Fetching with parameters",id:"fetching-with-parameters",level:3},{value:"Performance",id:"performance",level:2},{value:"Bundle size",id:"bundle-size",level:3},{value:"Caching and Prerendering",id:"caching-and-prerendering",level:3},{value:"Summary",id:"summary",level:2}];function f(e){const t={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.p,{children:"I've been using TanStack Start for a mid-size hobby webapp since its early alpha stage\u2014over a year now.\nI'm starting to feel I have enough experience, and since Start just entered a release candidate stage,\nit's time to share my insights with you."}),"\n",(0,r.jsx)(t.p,{children:"I will present Start by comparing it to Next.js."}),"\n","\n",(0,r.jsx)(t.p,{children:"Both are great pieces of software. In some cases very similar. In other cases very different."}),"\n",(0,r.jsx)(t.p,{children:"Notes:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["I assume you have basic knowledge of the Next.js App Router (",(0,r.jsx)(t.a,{href:"https://nextjs.org/docs/app/getting-started",children:"docs"}),")."]}),"\n",(0,r.jsxs)(t.li,{children:["This article is heavily inspired by my talk at FrontKon 2025 in Prague\n(",(0,r.jsx)(t.a,{href:"https://www.youtube.com/watch?v=wwiIgIKL7JA",children:"\ud83c\udfa5 YouTube"})," Czech only)."]}),"\n",(0,r.jsxs)(t.li,{children:["Actually, I compare TanStack Start (",(0,r.jsx)(t.a,{href:"https://tanstack.com/start/",children:"docs"}),") + TanStack Router\n(",(0,r.jsx)(t.a,{href:"https://tanstack.com/router/",children:"docs"}),') and reference both as just "Start" for simplicity.\nIt feels like a natural comparison since Next.js also includes a router.']}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"\xa0"}),"\n",(0,r.jsx)(t.h2,{id:"what-do-i-compare",children:"What do I compare?"}),"\n",(0,r.jsx)(t.p,{children:"I will compare Start to Next in the following areas.\nI chose these because, from my point of view, this is where the two frameworks differ the most."}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Routing - Typesafety"}),"\n",(0,r.jsx)(t.li,{children:"Data fetching - SSR, Streaming"}),"\n",(0,r.jsx)(t.li,{children:"Performance - Bundle size, Caching"}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["On the other hand, I will ",(0,r.jsx)(t.em,{children:"not"})," compare:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Non-technical differences","\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Like production readiness, Vercel lock-in, community, ecosystem, ..."}),"\n",(0,r.jsx)(t.li,{children:"Because I like to dig the technical differences."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["Areas where they are very similar","\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Server actions/functions, progressive enhancement, SEO, hosting, ..."}),"\n",(0,r.jsx)(t.li,{children:"Because there are mostly syntactical differences, and I'm not interested in these."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"\xa0"}),"\n",(0,r.jsx)(t.h2,{id:"routing",children:"Routing"}),"\n",(0,r.jsx)(t.p,{children:"\xa0"}),"\n",(0,r.jsx)(t.h3,{id:"route-definition",children:"Route definition"}),"\n",(0,r.jsxs)(t.p,{children:["Both frameworks support file-based routing. You define your pages based on your file/folder structure and naming conventions.\nThere are some minor differences.\nLike Next using ",(0,r.jsx)(t.code,{children:"page.tsx"})," and Start using ",(0,r.jsx)(t.code,{children:"index.tsx"})," files for page definition.\nOr ",(0,r.jsx)(t.code,{children:"[postId]"})," folder in Next and ",(0,r.jsx)(t.code,{children:"$postId"})," in Start as a dynamic route segment.\nJust syntactic sugar. No big difference here."]}),"\n",(0,r.jsx)(a.A,{}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"\ud83d\udcc1 blog\n\u251c\u2500 \ud83d\udcc1 [postId]\n\u2502  \u2514\u2500 \u269b page.tsx\n\u2514\u2500 \u269b page.tsx\n"})}),"\n",(0,r.jsx)(o.A,{}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"\ud83d\udcc1 blog\n\u251c\u2500 \ud83d\udcc1 $postId\n\u2502  \u2514\u2500 \u269b index.tsx\n\u2514\u2500 \u269b index.tsx\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Moving on. Start allows you to define so-called flat-route definitions. This means you can define your path in a file name instead of a folder.\nFor example, a single file in the root folder ",(0,r.jsx)(t.code,{children:"/blog.$postId.tsx"})," in Start will define the same route as ",(0,r.jsx)(t.code,{children:"/blog/[postId]/page.tsx"})," in Next.\nFrom my experience, it is often useful and readable,\nespecially when you use it in combination with classic nested folders definitions."]}),"\n",(0,r.jsx)(o.A,{}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-markup",metastring:'title="Flat-route definition"',children:"\u269b blog.tsx\n\u269b blog.$postId.tsx\n"})}),"\n",(0,r.jsx)(o.A,{}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-markup",metastring:'title="Combined flat-route with nested folders"',children:"\ud83d\udcc1 blog\n\u251c\u2500 \u269b $postId.tsx\n\u2514\u2500 \u269b index.tsx\n"})}),"\n",(0,r.jsx)(t.p,{children:"\xa0"}),"\n",(0,r.jsx)(t.h3,{id:"page-config",children:"Page config"}),"\n",(0,r.jsx)(t.p,{children:"Now let's look inside a page file. Next.js uses an extremely brief and readable syntax. Love it."}),"\n",(0,r.jsx)(a.A,{}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-tsx",metastring:'title="/blog/page.tsx"',children:"export default function Blog() {\n  return <div/>;\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Start is a little more complicated. We need to use the ",(0,r.jsx)(t.code,{children:"createFileRoute(...)"})," function.\nWorth pointing out its first argument ",(0,r.jsx)(t.code,{children:"/blog"}),".\nIt's the route identifier and is used internally to infer TypeScript types.\nWhat's convenient is that the first line is auto-generated\nand the route identifier is derived from the file name by Start dev server.\nThis way it prevents typos and misalignments between the file name, route identifier and type inference."]}),"\n",(0,r.jsx)(o.A,{}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-tsx",metastring:'title="/blog/index.tsx"',children:'  // highlight-next-line\nexport const Route = createFileRoute("/blog")({ // this is auto-generated\n  component: Blog,\n});\n\nfunction Blog() {\n  return <div/>;\n}\n'})}),"\n",(0,r.jsx)(t.p,{children:"\xa0"}),"\n",(0,r.jsx)(t.h3,{id:"router-typesafety",children:"Router typesafety"}),"\n",(0,r.jsxs)(t.p,{children:["Now let's look at how the dynamic route segment parameter ",(0,r.jsx)(t.code,{children:"postId"})," is used. In Start, it's pretty simple\u2014just use the ",(0,r.jsx)(t.code,{children:"useParams"})," hook.\nIt's worth mentioning that ",(0,r.jsx)(t.code,{children:"useParams"})," is typesafe, and your IDE will suggest available param names and catch typos."]}),"\n",(0,r.jsx)(o.A,{}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-tsx",metastring:'title="/blog/$postId.tsx"',children:'export const Route = createFileRoute("/blog/$postId")({\n  component: BlogPost,\n});\n\nfunction BlogPost() {\n  // highlight-next-line\n  const { postId } = Route.useParams();\n  return <div>{postId}</div>;\n}\n'})}),"\n",(0,r.jsxs)(t.p,{children:["Let's look at how it is done in Next. See that it also needs a route identifier to infer types. This way, ",(0,r.jsx)(t.code,{children:"params"})," are also typed.\nNote that this only works if you use the ",(0,r.jsx)(t.code,{children:"typedRoutes"})," feature\n(",(0,r.jsx)(t.a,{href:"https://nextjs.org/docs/app/api-reference/config/typescript#statically-typed-links",children:"docs"}),").\nWithout it, there's no type inference, your IDE won't offer suggestions, and AI agents won't benefit from it either."]}),"\n",(0,r.jsx)(a.A,{}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-tsx",metastring:'title="/blog/[postId]/page.tsx"',children:'export default async function BlogPost(\n  // highlight-next-line\n  { params }: PageProps<"/blog/[postId]">\n) {\n  const { postId } = await params;\n  return <div>{postId}</div>;\n}\n'})}),"\n",(0,r.jsxs)(t.p,{children:["I love how competition is driving change here.\nWhen TanStack Router came out with its awesome and convenient end-to-end typesafe system, developers loved it.\nQuickly it forced Next.js and Remix to invest in it too. In version 15.5, Next.js introduced a new ",(0,r.jsx)(t.code,{children:"typedRoutes"})," feature\n(",(0,r.jsx)(t.a,{href:"https://nextjs.org/blog/next-15-5#typed-routes-stable",children:"blog post"}),").\nIt is not enabled by default, and I highly suggest enabling it.\nIt's a great ",(0,r.jsx)("abbr",{title:"Developer Experience",children:"DX"})," improvement; however, you might be surprised that it is not as reliable as you would expect.\nLet's see some examples."]}),"\n",(0,r.jsxs)(t.p,{children:["Firstly, a ",(0,r.jsx)(t.code,{children:"<Link/>"})," component. As you can see, Next can't infer routes with dynamic segments, and therefore your IDE is not able to suggest all available routes.\nInconvenient for devs and from my experience it confuses AI agents too."]}),"\n",(0,r.jsx)(a.A,{}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-tsx",children:'<Link href="">Blog Post</Link>\n//          \u2b11 IDE suggests:\n//            \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n//            \u2503 /       \u2503\n//            \u2503 /blog   \u2503\n//            \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n'})}),"\n",(0,r.jsx)(o.A,{}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-tsx",children:'<Link to="">Blog Post</Link>\n//        \u2b11 IDE suggests:\n//          \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n//          \u2503 /             \u2503\n//          \u2503 /blog/        \u2503\n// highlight-next-line\n//          \u2503 /blog/$postId \u2503\n//          \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n'})}),"\n",(0,r.jsxs)(t.p,{children:["Another example. Next does not URL-encode dynamic parameters. In this case, Next renders a ",(0,r.jsx)(t.code,{children:'<a href="/blog/">'})," tag referencing the blog page.\nAllowing it, even if route ",(0,r.jsx)(t.code,{children:"/blog/"})," is not defined anywhere in our app. Type checking passes, and users end up on a 404 page."]}),"\n",(0,r.jsx)(a.A,{}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-tsx",children:'<Link href="/blog/ ">\n  Blog Post\n</Link>\n'})}),"\n",(0,r.jsxs)(t.p,{children:["Start correctly encodes the space and renders a ",(0,r.jsx)(t.code,{children:'<a href="/blog/%20">'})," tag\npointing to the blog post page with ",(0,r.jsx)(t.code,{children:"postId"})," being a space (encoded as ",(0,r.jsx)(t.code,{children:"%20"}),").\nI know it's a rare case, but it does make me keep checking for correctness in Next."]}),"\n",(0,r.jsx)(o.A,{}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-tsx",children:'<Link to="/blog/$postId" params={{ postId: " " }}>\n  Blog Post\n</Link>\n'})}),"\n",(0,r.jsxs)(t.p,{children:["And in my opinion, the biggest Next flaw: it does not type search query params. At all.\nYou are on your own. Start has you covered. It even supports validation libraries like Zod for more complex data structures\n(",(0,r.jsx)(t.a,{href:"https://tanstack.com/router/latest/docs/framework/react/guide/search-params#validating-and-typing-search-params",children:"docs"}),")."]}),"\n",(0,r.jsx)(o.A,{}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-tsx",children:'export const Route = createFileRoute("/blog")({\n  component: Blog,\n  validateSearch: z.object({\n  // highlight-next-line\n    postId: z.string().optional(),\n  }),\n});\n'})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-tsx",children:'<Link \n  to="/blog"\n  // highlight-next-line\n  search={{ postId: "123" }}\n>\n  Blog Post\n</Link>\n'})}),"\n",(0,r.jsx)(t.p,{children:"\xa0"}),"\n",(0,r.jsx)(t.p,{children:"\xa0"}),"\n",(0,r.jsxs)(t.p,{children:["To summarize: Start is more flexible in defining routes. It supports file-based with flat-config definition.\nStart forced Next to introduce the ",(0,r.jsx)(t.code,{children:"typedRoutes"})," feature. Turn it on if you use Next.\nHowever even with it enabled, Next is not 100% typesafe. Start is, and it is very convenient for both devs and AI agents.\n(Here it may seem I'm talking about Start advantages and Next flaws only. But later I also highlight the opposite. Keep reading :)"]}),"\n",(0,r.jsx)(t.p,{children:"\xa0"}),"\n",(0,r.jsx)(t.h2,{id:"data-fetching",children:"Data fetching"}),"\n",(0,r.jsx)(t.p,{children:"\xa0"}),"\n",(0,r.jsx)(t.h3,{id:"collocation",children:"Collocation"}),"\n",(0,r.jsx)(t.p,{children:"This is how Next.js loads data.\nJust use an async component and await within the component body.\nExtremely convenient."}),"\n",(0,r.jsx)(a.A,{}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-tsx",children:"async function Blog() {\n  // highlight-next-line\n  const posts = await getPosts();\n  return posts.map(() => <>...</>);\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["In Start's ",(0,r.jsx)(t.a,{href:"https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#route-loaders",children:"documentation"}),", the recommended way is to use the Route loader."]}),"\n",(0,r.jsx)(o.A,{}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-tsx",children:'export const Route = createFileRoute("/blog")({\n  component: Blog,\n  // highlight-next-line\n  loader: async () => await getPosts(),\n});\n\nfunction Blog() {\n  // highlight-next-line\n  const posts = Route.useLoaderData();\n  return posts.map(() => <>...</>);\n}\n'})}),"\n",(0,r.jsxs)(t.p,{children:["Personally, I do not like this pattern. It is more verbose.\nBut what's more important than syntax is that the component becomes dependent on a route.\nThe Blog component cannot be easily used elsewhere in the app.\nI always have to remember to update the parent route loader as well.\nIn the case of a Blog component, it is quite simple, but imagine a deeper and more reusable component\nlike an ",(0,r.jsx)(t.code,{children:"<AuthorAvatar/>"})," with a tooltip.\nIt can be used on a blog post page, then extended to a list of posts, list of authors, author details page, favourite posts, etc.\nIn all those places, I would need to remember to update the parent route loader."]}),"\n",(0,r.jsx)(t.p,{children:"Therefore, I recommend integrating TanStack Start with TanStack Query.\nThe data loading example would then look like this."}),"\n",(0,r.jsx)(o.A,{}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-tsx",children:"function Blog() {\n  // highlight-next-line\n  const posts = useSuspenseQuery({\n    queryKey: ['posts'],\n    queryFn: () => getPosts(),\n  });\n  return posts.data.map(() => <>...</>);\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:"It's still more verbose than Next, but we get rid of the route dependency."}),"\n",(0,r.jsxs)(t.p,{children:["You may think that this way it stops being prefetched and may create waterfalls. And you'd be correct.\nHowever ",(0,r.jsx)(t.code,{children:"useSuspenseQuery"})," can opt-in to being prefetched.\nBoth frameworks do it similarly by hoisting the query to the top of the route.\nNext uses ",(0,r.jsx)(t.code,{children:"void getPosts()"})," syntax, Start uses ",(0,r.jsx)(t.code,{children:"queryClient.fetchQuery(...)"}),".\nI will not go into details. Let's just say both frameworks are very similar."]}),"\n",(0,r.jsx)(t.p,{children:"\xa0"}),"\n",(0,r.jsx)(t.h3,{id:"streaming",children:"Streaming"}),"\n",(0,r.jsx)(t.p,{children:"There is another way to compare Next and Start data fetching: performance.\nLet's look at the request timeline of Next request with awaited data fetching."}),"\n",(0,r.jsx)(a.A,{}),"\n",(0,r.jsxs)(l.Kf,{children:[(0,r.jsx)(l.Pl,{children:(0,r.jsx)(l.CU,{start:0,title:"Request"})}),(0,r.jsxs)(l.LG,{start:0,end:"FCP+LCP",children:[(0,r.jsx)(l.eB,{type:"server",duration:1}),(0,r.jsx)(l.eB,{type:"fetch",duration:8}),(0,r.jsx)(l.eB,{type:"server",duration:2}),(0,r.jsx)(l.eB,{type:"network",duration:4}),(0,r.jsx)(l.eB,{type:"client",duration:1})]})]}),"\n",(0,r.jsxs)(t.p,{children:["You can see that awaiting data in Next.js blocks rendering on the server during the fetch. The ",(0,r.jsx)("abbr",{title:"First Contentful Paint",children:"FCP"})," metric suffers.\nStart does the same. It's actually even a little worse because it typically needs to transfer more data over the network to the client.\nBecause Start does not support React Server Components (yet, ",(0,r.jsx)(t.a,{href:"https://tanstack.com/blog/tanstack-2-years#whats-next",children:"blog post"}),"),\nit has to transfer more JS components together with data needed to hydrate them."]}),"\n",(0,r.jsx)(o.A,{}),"\n",(0,r.jsxs)(l.Kf,{children:[(0,r.jsx)(l.Pl,{children:(0,r.jsx)(l.CU,{start:0,title:"Request"})}),(0,r.jsxs)(l.LG,{start:0,end:"FCP+LCP",children:[(0,r.jsx)(l.eB,{type:"server",duration:1}),(0,r.jsx)(l.eB,{type:"fetch",duration:8}),(0,r.jsx)(l.eB,{type:"server",duration:2}),(0,r.jsx)(l.eB,{type:"network",duration:5}),(0,r.jsx)(l.eB,{type:"client",duration:1})]})]}),"\n",(0,r.jsxs)(t.p,{children:["Fortunately, both frameworks support streaming.\nBoth adopted React's ",(0,r.jsx)(t.code,{children:"<Suspense/>"})," component, and luckily for us, without any configuration.\nIt's enough to just wrap our component within ",(0,r.jsx)(t.code,{children:"<Suspense/>"}),",\nand the content will be streamed, greatly improving both ",(0,r.jsx)("abbr",{title:"First Contentful Paint",children:"FCP"})," and ",(0,r.jsx)("abbr",{title:"Largest Contentful Paint",children:"LCP"}),"."]}),"\n",(0,r.jsx)(a.A,{cls:"-left-7"}),"\n",(0,r.jsx)(o.A,{}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-tsx",children:"<Suspense>\n  <Blog />\n</Suspense>\n"})}),"\n",(0,r.jsx)(a.A,{cls:"-left-7"}),"\n",(0,r.jsx)(o.A,{}),"\n",(0,r.jsxs)(l.Kf,{children:[(0,r.jsx)(l.Pl,{children:(0,r.jsx)(l.CU,{start:0,title:"Request"})}),(0,r.jsxs)(l.LG,{start:0,end:"FCP",children:[(0,r.jsx)(l.eB,{type:"server",duration:3}),(0,r.jsx)(l.eB,{type:"network",duration:4}),(0,r.jsx)(l.eB,{type:"client",duration:1})]}),(0,r.jsxs)(l.LG,{start:1,end:"LCP",children:[(0,r.jsx)(l.eB,{type:"fetch",duration:8}),(0,r.jsx)(l.eB,{type:"server",duration:1}),(0,r.jsx)(l.eB,{type:"network",duration:3}),(0,r.jsx)(l.eB,{type:"client",duration:1})]})]}),"\n",(0,r.jsx)(t.p,{children:"\xa0"}),"\n",(0,r.jsx)(t.h3,{id:"fetching-with-parameters",children:"Fetching with parameters"}),"\n",(0,r.jsxs)(t.p,{children:["Often you need to pass some parameters to the fetching endpoint, like ",(0,r.jsx)(t.code,{children:"postId"}),".\nWe already covered how to get route params in the ",(0,r.jsx)(t.a,{href:"#router-typesafety",children:"Routing section"}),".\nNow let's just combine it with fetching."]}),"\n",(0,r.jsxs)(t.p,{children:["In Start, we can simply use the ",(0,r.jsx)(t.code,{children:"useParams"})," hook directly in the component and pass ",(0,r.jsx)(t.code,{children:"postId"})," to the query.\nThe syntax is a little verbose, but I love the collocation of code and component independence."]}),"\n",(0,r.jsx)(o.A,{}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-tsx",children:"function BlogPost() {\n  // highlight-next-line\n  const { postId } = Route.useParams();\n  const post = useSuspenseQuery({\n    queryKey: ['posts', postId],\n    queryFn: () => getPost(postId),\n  });\n  return <div>{post.title}</div>;\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["In Next.js, we access the ",(0,r.jsx)(t.code,{children:"params"})," prop in the page component. Seems pretty straightforward.\nBut there is a catch. Do you see it?"]}),"\n",(0,r.jsx)(a.A,{}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-tsx",children:'// /blog/page.tsx\nexport default async function BlogPost(\n  { params }: PageProps<"/blog/[postId]">\n) {\n  // highlight-next-line\n  const { postId } = await params;\n  const post = await getPost(postId);\n  return <div>{post.title}</div>;\n}\n'})}),"\n",(0,r.jsxs)(t.p,{children:["In Next, we can only get ",(0,r.jsx)(t.code,{children:"params"})," prop in the root page component. ",(0,r.jsx)(t.code,{children:"params"})," are ",(0,r.jsx)(t.em,{children:"not"})," accessible in nested components.\nThis can cause problems. Imagine the ",(0,r.jsx)(t.code,{children:"<AuthorAvatar/>"})," component again, which consumes the ",(0,r.jsx)(t.code,{children:"postId"})," param.\nIt will be nested somewhere deep in the component tree."]}),"\n",(0,r.jsxs)(t.p,{children:["We need to drill ",(0,r.jsx)(t.code,{children:"postId"})," through each component of the tree until we reach the ",(0,r.jsx)(t.code,{children:"<AuthorAvatar/>"})," component.\nYour first idea is probably to use React Context to avoid prop drilling. But it is not allowed in server components.\nIt throws\n",(0,r.jsx)("mark",{class:"error",children:"Error: React Context is unavailable in Server Components"}),".\nOuch. We either need to prop drill, use client components, or refactor our component structure.\nEither way, it is a lot of work for such a common task."]}),"\n",(0,r.jsx)(a.A,{}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-tsx",children:"<BlogPostPage/>\n      \u2b07 postId\n<PostContent/>\n      \u2b07 postId\n<PostHeader/>\n      \u2b07 postId\n<PostAuthor/>\n      \u2b07 postId\n<AuthorAvatar/>\n"})}),"\n",(0,r.jsx)(t.p,{children:"\xa0"}),"\n",(0,r.jsx)(t.p,{children:"\xa0"}),"\n",(0,r.jsxs)(t.p,{children:["To summarize data fetching:\nI recommend integrating Start with TanStack Query for better code collocation, component reusability, and independence.\nBoth Next and Start support streaming via ",(0,r.jsx)(t.code,{children:"<Suspense/>"})," out of the box. And both frameworks can avoid network waterfalls similarly.\nNext uses more concise syntax, but it is not as ergonomic when accessing params in nested components."]}),"\n",(0,r.jsx)(t.p,{children:"\xa0"}),"\n",(0,r.jsx)(t.h2,{id:"performance",children:"Performance"}),"\n",(0,r.jsx)(t.p,{children:"\xa0"}),"\n",(0,r.jsx)(t.h3,{id:"bundle-size",children:"Bundle size"}),"\n",(0,r.jsxs)(t.p,{children:["So far, it looks like TanStack Start is overall better than Next. But here Start loses.\nStart does not support React Server Components yet (",(0,r.jsx)(t.a,{href:"https://tanstack.com/blog/tanstack-2-years#whats-next",children:"blog post"}),"),\nand therefore all code is bundled and shipped to the client\u2014even parts that are static and don't update on the client.\nNext allows you to select which components go to the client and which ones stay server-only.\nServer-only is the default and component is sent to the client only when marked with ",(0,r.jsx)(t.code,{children:'"use client"'}),".\nIt can make the client bundle smaller.\nThis means less code is shipped to the client, resulting in less network transfer, faster hydration time, and therefore faster ",(0,r.jsx)("abbr",{title:"Time to Interactive",children:"TTI"}),"."]}),"\n",(0,r.jsx)(a.A,{}),"\n",(0,r.jsxs)(l.Kf,{children:[(0,r.jsx)(l.Pl,{children:(0,r.jsx)(l.CU,{start:0,title:"Request"})}),(0,r.jsxs)(l.LG,{start:0,end:"FCP",children:[(0,r.jsx)(l.eB,{type:"server",duration:2}),(0,r.jsx)(l.eB,{type:"network",duration:3,title:"HTML doc"}),(0,r.jsx)(l.eB,{type:"client",duration:1,title:"Processing HTML"})]}),(0,r.jsxs)(l.LG,{start:6,end:"TTI",children:[(0,r.jsx)(l.eB,{type:"server",duration:1}),(0,r.jsx)(l.eB,{type:"network",duration:5,title:"Bundle transfer"}),(0,r.jsx)(l.eB,{type:"client",duration:2,title:"Hydration"})]})]}),"\n",(0,r.jsx)(o.A,{}),"\n",(0,r.jsxs)(l.Kf,{children:[(0,r.jsx)(l.Pl,{children:(0,r.jsx)(l.CU,{start:0,title:"Request"})}),(0,r.jsxs)(l.LG,{start:0,end:"FCP",children:[(0,r.jsx)(l.eB,{type:"server",duration:2}),(0,r.jsx)(l.eB,{type:"network",duration:3,title:"HTML doc"}),(0,r.jsx)(l.eB,{type:"client",duration:1,title:"Processing HTML"})]}),(0,r.jsxs)(l.LG,{start:6,end:"TTI",children:[(0,r.jsx)(l.eB,{type:"server",duration:1}),(0,r.jsx)(l.eB,{type:"network",duration:9,title:"Bundle transfer"}),(0,r.jsx)(l.eB,{type:"client",duration:3,title:"Hydration"})]})]}),"\n",(0,r.jsx)(t.p,{children:"Depending on how static your app content is, this can have a significant impact on performance.\nLet's briefly go through the examples of a static and a dynamic component."}),"\n",(0,r.jsxs)(t.p,{children:["A static component could be a ",(0,r.jsx)(t.code,{children:"<NavigationBar/>"})," or an ",(0,r.jsx)(t.code,{children:"<ArticleContent/>"}),". You can still update them sometimes,\nbut it is probably fine if they are stale for a few minutes or even hours after the update."]}),"\n",(0,r.jsxs)(t.p,{children:["A dynamic component could be a ",(0,r.jsx)(t.code,{children:"<CommentSection/>"})," or a ",(0,r.jsx)(t.code,{children:"<LikesCounter/>"}),".\nIt would be a problem if a user sent a comment or pressed a like button but needed to wait several minutes or hours to see it reflected on the page."]}),"\n",(0,r.jsx)(t.p,{children:"That being said, Next has quite a performance advantage in highly static apps\u2014or what some would call websites."}),"\n",(0,r.jsx)(t.p,{children:"\xa0"}),"\n",(0,r.jsx)(t.h3,{id:"caching-and-prerendering",children:"Caching and Prerendering"}),"\n",(0,r.jsxs)(t.p,{children:["Next defines 4 layers of caching (",(0,r.jsx)(t.a,{href:"https://nextjs.org/docs/14/app/building-your-application/caching#overview",children:"docs"}),").\nStart fully supports 3 of them. Full Route Cache is supported partially. Let's talk about it."]}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{style:{textAlign:"left"},children:"Cache layer"}),(0,r.jsx)(t.th,{style:{textAlign:"left"},children:"What it caches"}),(0,r.jsx)(t.th,{style:{textAlign:"left"},children:"Purpose"}),(0,r.jsx)(t.th,{style:{textAlign:"left"},children:(0,r.jsx)("img",{src:c.A,alt:"Next Logo",className:"w-8 block"})}),(0,r.jsx)(t.th,{style:{textAlign:"left"},children:(0,r.jsx)("img",{src:d.A,alt:"Start Logo",className:"w-8 block"})})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Request Memoization"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Return values of functions"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Re-uses data in a React Component tree on a server during one request"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"\ud83d\udfe2"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"\ud83d\udfe2"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Data Cache"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Data"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Stores data across user requests and deployments"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"\ud83d\udfe2"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"\ud83d\udfe2"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Full Route Cache"}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["HTML and ",(0,r.jsx)("abbr",{title:"React Server Components",children:"RSC"})," payload"]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Reduces server rendering effort for each request"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"\ud83d\udfe2"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"\ud83d\udfe0"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Router Cache"}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)("abbr",{title:"React Server Components",children:"RSC"})," Payload"]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Reduces server requests on navigation"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"\ud83d\udfe2"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"\ud83d\udfe2"})]})]})]}),"\n",(0,r.jsxs)(t.p,{children:["You might know Full Route Cache under other names like Prerendering or Static Generation.\nThe main idea is to render a page once\u2014either during build time or during the first request\u2014store the rendered HTML, and serve it from cache on subsequent requests.\nThis way, the best ",(0,r.jsx)("abbr",{title:"First Contentful Paint",children:"FCP"})," is achieved.\nBoth Start and Next support this feature. Next has it enabled by default;\nStart is opt-in (",(0,r.jsx)(t.a,{href:"https://tanstack.com/start/latest/docs/framework/react/guide/static-prerendering",children:"docs"}),").\nNext has an easier way to invalidate cache. As far as I know, Start needs to rebuild all pages,\nwhich is not a problem for small apps, but for large ones it can take a while and is annoying.\nNevertheless, for the end user, the experience and performance are equal."]}),"\n",(0,r.jsx)(a.A,{cls:"-left-7"}),"\n",(0,r.jsx)(o.A,{}),"\n",(0,r.jsxs)(l.Kf,{children:[(0,r.jsxs)(l.Pl,{children:[(0,r.jsx)(l.CU,{start:0,title:"Build"}),(0,r.jsx)(l.CU,{start:8,title:"Request"})]}),(0,r.jsxs)(l.LG,{start:0,children:[(0,r.jsx)(l.eB,{type:"server",duration:1}),(0,r.jsx)(l.eB,{type:"fetch",duration:5}),(0,r.jsx)(l.eB,{type:"server",duration:1})]}),(0,r.jsxs)(l.LG,{start:8,end:"FCP",children:[(0,r.jsx)(l.eB,{type:"server",duration:1}),(0,r.jsx)(l.eB,{type:"network",duration:3}),(0,r.jsx)(l.eB,{type:"client",duration:1})]})]}),"\n",(0,r.jsxs)(t.p,{children:["In the real world however, a lot of pages are not fully static or fully dynamic. They contain some static and some dynamic parts\u2014components.\nImagine a blog post page. It contains a header with author avatar and name, article content, and a comments section.\n",(0,r.jsx)(t.code,{children:"<Author/>"})," and ",(0,r.jsx)(t.code,{children:"<Article/>"})," are static, but because of the ",(0,r.jsx)(t.code,{children:"<Comments/>"})," component, we would not be able to prerender and cache the page."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-tsx",children:"            <BlogPostPage/>\n      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  <Author/>   <Article/>   <Comments/>\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Next solves this problem with Cached Components (",(0,r.jsx)(t.a,{href:"https://nextjs.org/docs/app/getting-started/cache-components",children:"docs"}),", previously called Partial Prerendering).\nThis way, some components (called shell) are rendered during build and sent to the client immediately when requested,\nwhile the server fetches dynamic data, renders the rest, and streams it to the client.\nThis way, we can prerender the ",(0,r.jsx)(t.code,{children:"<Author/>"})," and ",(0,r.jsx)(t.code,{children:"<Article/>"})," components and stream the ",(0,r.jsx)(t.code,{children:"<Comments/>"})," section during the request.\nStart does not provide any support for Cached Components."]}),"\n",(0,r.jsx)(a.A,{}),"\n",(0,r.jsxs)(l.Kf,{children:[(0,r.jsxs)(l.Pl,{children:[(0,r.jsx)(l.CU,{start:0,title:"Build"}),(0,r.jsx)(l.CU,{start:8,title:"Request"})]}),(0,r.jsxs)(l.LG,{start:0,children:[(0,r.jsx)(l.eB,{type:"server",duration:1}),(0,r.jsx)(l.eB,{type:"fetch",duration:5}),(0,r.jsx)(l.eB,{type:"server",duration:1})]}),(0,r.jsxs)(l.LG,{start:8,end:"FCP",children:[(0,r.jsx)(l.eB,{type:"server",duration:2}),(0,r.jsx)(l.eB,{type:"network",duration:3}),(0,r.jsx)(l.eB,{type:"client",duration:1})]}),(0,r.jsxs)(l.LG,{start:9,end:"LCP",children:[(0,r.jsx)(l.eB,{type:"fetch",duration:6}),(0,r.jsx)(l.eB,{type:"server",duration:1}),(0,r.jsx)(l.eB,{type:"network",duration:2}),(0,r.jsx)(l.eB,{type:"client",duration:1})]})]}),"\n",(0,r.jsx)(t.p,{children:"\xa0"}),"\n",(0,r.jsx)(t.p,{children:"\xa0"}),"\n",(0,r.jsxs)(t.p,{children:["To summarize: Start has a lot of performance optimizations, but Next wins, especially for highly static websites.\nNext supports ",(0,r.jsx)("abbr",{title:"React Server Components",children:"RSC"}),", which results in a smaller bundle and faster ",(0,r.jsx)("abbr",{title:"Time to Interactive",children:"TTI"})," for end users.\nNext supports Cached Components, which improves ",(0,r.jsx)("abbr",{title:"First Contentful Paint",children:"FCP"})," for static pages with some dynamic parts."]}),"\n",(0,r.jsx)(t.p,{children:"\xa0"}),"\n",(0,r.jsx)(t.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(t.p,{children:"So which one is better? Next or Start?"}),"\n",(0,r.jsxs)("div",{className:"flex flex-col gap-1 pb-6 w-fit",children:[(0,r.jsxs)("div",{className:"rounded-md pr-4 p-2 bg-[#212432] w-fit flex items-center gap-2  mx-2 mr-4",children:[(0,r.jsx)("img",{src:c.A,alt:"Next Logo",className:"w-8 block relative -ml-6"}),(0,r.jsx)(r.Fragment,{children:"Concise syntax that feels productive"})]}),(0,r.jsxs)("div",{className:"rounded-md pl-4 p-2 bg-[#212432] w-fit self-end flex items-center gap-2 mx-2 ml-4",children:[(0,r.jsx)(r.Fragment,{children:"Flexible route definition with flat-config"}),(0,r.jsx)("img",{src:d.A,alt:"Start Logo",className:"w-8 block relative -mr-6"})]}),(0,r.jsxs)("div",{className:"rounded-md pr-4 p-2 bg-[#212432] w-fit flex items-center gap-2  mx-2 mr-4",children:[(0,r.jsx)("img",{src:c.A,alt:"Next Logo",className:"w-8 block relative -ml-6"}),(0,r.jsx)(r.Fragment,{children:"Smaller bundle size and therefore better TTI"})]}),(0,r.jsxs)("div",{className:"rounded-md pl-4 p-2 bg-[#212432] w-fit self-end flex items-center gap-2  mx-2 ml-4",children:[(0,r.jsx)(r.Fragment,{children:"Advanced router typesafety that I can rely on"}),(0,r.jsx)("img",{src:d.A,alt:"Start Logo",className:"w-8 block relative -mr-6"})]}),(0,r.jsxs)("div",{className:"rounded-md pr-4 p-2 bg-[#212432] w-fit flex items-center gap-2  mx-2 mr-4",children:[(0,r.jsx)("img",{src:c.A,alt:"Next Logo",className:"w-8 block relative -ml-6"}),(0,r.jsx)(r.Fragment,{children:"Granular prerendering and therefore better FCP"})]}),(0,r.jsxs)("div",{className:"rounded-md pl-4 p-2 bg-[#212432] w-fit self-end flex items-center gap-2 mx-2 ml-4",children:[(0,r.jsx)(r.Fragment,{children:"Ergonomic access to path params with better collocation"}),(0,r.jsx)("img",{src:d.A,alt:"Start Logo",className:"w-8 block relative -mr-6"})]})]}),"\n",(0,r.jsx)(t.p,{children:"Both are trying to catch up with each other. But if I had to simplify and answer in a single sentence:"}),"\n",(0,r.jsxs)(t.blockquote,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Next.js app is more performant for end users"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(t.strong,{children:"TanStack Start app is easier to develop and maintain"})]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Currently, I would recommend using Next for mostly static websites where its performance-focused approach can outshine Start,\nor where site performance has a high impact on your business\u2014for example, when you know every 100 ms of latency costs you $$$ in revenue."}),"\n",(0,r.jsxs)(t.p,{children:["In all other cases, I would recommend using TanStack Start.\nIt's performant enough for most cases, and due to its better ",(0,r.jsx)("abbr",{title:"Developer Experience",children:"DX"}),", it can save you time during development and maintenance.\nAnd it scales for bigger apps."]}),"\n",(0,r.jsx)(t.p,{children:"Lastly, I want to say I love seeing the frontend market grow and competition pushing and inspiring each other to improve."}),"\n",(0,r.jsx)(t.p,{children:"Thank you for reading."}),"\n","\n",(0,r.jsx)(x,{})]})}function y(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(f,{...e})}):f(e)}},2961:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/start-logo-f36136323c47d1a46f9daf37146c14f1.png"},3331:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>o});var s=n(8101);const r={},i=s.createContext(r);function a(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(i.Provider,{value:t},e.children)}},3742:(e,t,n)=>{n.d(t,{C:()=>r,T:()=>i});n(8101);var s=n(5105);function r(e){let{children:t,...n}=e;return(0,s.jsxs)("li",{...n,children:[(0,s.jsx)("span",{className:"bg-[rgba(0,255,0,0.15)] rounded-full font-bold text-[rgba(200,255,150,0.65)] text-center inline-block leading-4 pb-1 w-5 align-text-top",children:"+"})," ",t]})}function i(e){let{children:t,...n}=e;return(0,s.jsxs)("li",{...n,children:[(0,s.jsx)("span",{className:"bg-[rgba(255,50,0,0.2)] rounded-full font-black text-[rgba(255,170,150.8)] text-center inline-block leading-4 pb-1 w-5 align-text-top",children:"-"})," ",t]})}},4116:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/next-logo-bb413fcd7cd97e20e9f376e923597572.png"},5906:(e,t,n)=>{n.d(t,{A:()=>r});var s=n(5105);function r(e){return(0,s.jsx)("div",{className:`flex justify-end z-20 relative ${e.cls}`,children:(0,s.jsx)("img",{alt:e.alt,className:"w-8 h-8 -m-4 relative -left-8",...e})})}},7137:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/tanstack-start-new-competitor-to-nextjs-879fbbc61b453a63effa71b32b3959c3.png"},8182:(e,t,n)=>{n.d(t,{A:()=>a});var s=n(5906),r=n(2961),i=n(5105);function a(){return(0,i.jsx)(s.A,{src:r.A,alt:"Start Logo"})}},8730:e=>{e.exports=JSON.parse('{"permalink":"/tanstack-start-new-competitor-to-nextjs","source":"@site/blog/2025-11-17-tanstack-start-new-competitor-to-nextjs/index.mdx","title":"TanStack Start: New competitor to Next.js","description":"I\'ve been using TanStack Start for a mid-size hobby webapp since its early alpha stage\u2014over a year now.","date":"2025-11-17T00:00:00.000Z","tags":[],"readingTime":16.87,"hasTruncateMarker":true,"authors":[],"frontMatter":{"slug":"tanstack-start-new-competitor-to-nextjs","image":"./tanstack-start-new-competitor-to-nextjs.png","draft":false,"unlisted":false},"unlisted":false,"nextItem":{"title":"Avoid the State Synchronization Trap","permalink":"/avoid-state-synchronization-trap"}}')},9013:(e,t,n)=>{n.d(t,{A:()=>a});var s=n(5906),r=n(4116),i=n(5105);function a(e){return(0,i.jsx)(s.A,{src:r.A,alt:"Next Logo",cls:e.cls})}}}]);